<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>NOTAMY TETRIS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        :root {
            --primary-teal: #00b4a6;
            --primary-light: #00d9ff;
            --cyan-neon: #00ffff;
            --cyan-deep: #00cccc;
            --purple-accent: #b366ff;
            --pink-neon: #ff6b6b;
            --orange-neon: #ffab00;
            --green-neon: #00e676;
            --black-deep: #000000;
            --black-soft: #0a0a0a;
            --white: #ffffff;
        }
        
        body {
            background: var(--black-deep);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        /* Neon Grid Background */
        .neon-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 180, 166, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 180, 166, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -2;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: transparent;
            display: flex;
            flex-direction: column;
        }
        
        /* Top UI */
        .top-ui {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            z-index: 100;
        }
        
        .time-display {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--pink-neon);
            border-radius: 25px;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .time-label {
            font-size: 14px;
            color: var(--pink-neon);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .time-value {
            font-size: 28px;
            font-weight: 900;
            color: var(--white);
            text-shadow: 0 0 20px var(--pink-neon);
            min-width: 40px;
            text-align: center;
        }
        
        .score-display {
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--primary-teal);
            border-radius: 25px;
            padding: 8px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 30px rgba(0, 180, 166, 0.5);
            backdrop-filter: blur(10px);
        }
        
        .score-label {
            font-size: 14px;
            color: var(--primary-teal);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .score-value {
            font-size: 28px;
            font-weight: 900;
            color: var(--white);
            text-shadow: 0 0 20px var(--primary-teal);
            min-width: 80px;
            text-align: right;
        }
        
        /* Canvas area */
        .canvas-area {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid var(--primary-teal);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 
                0 0 50px rgba(0, 180, 166, 0.5),
                inset 0 0 30px rgba(0, 180, 166, 0.1);
            backdrop-filter: blur(20px);
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 20, 0.95) 100%);
            border-radius: 10px;
        }
        
        /* Time bonus popup */
        .time-bonus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: 900;
            color: var(--green-neon);
            text-shadow: 0 0 50px currentColor;
            pointer-events: none;
            opacity: 0;
            z-index: 200;
            text-align: center;
        }
        
        .time-bonus.show {
            animation: timeBonusAnim 1.5s ease-out;
        }
        
        @keyframes timeBonusAnim {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0) rotate(-360deg);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1) translateY(-100px);
            }
        }
        
        /* Particles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
        }
        
        /* Game over */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .game-over-title {
            font-size: 56px;
            font-weight: 900;
            color: var(--pink-neon);
            margin-bottom: 20px;
            text-shadow: 0 0 40px currentColor;
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .final-score {
            font-size: 32px;
            color: var(--white);
            margin-bottom: 40px;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, var(--primary-teal), var(--primary-light));
            border: none;
            color: var(--black-deep);
            padding: 15px 50px;
            border-radius: 40px;
            font-size: 24px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 40px rgba(0, 180, 166, 0.5);
            transition: all 0.3s ease;
        }
        
        .restart-btn:active {
            transform: scale(0.95);
        }
        
        /* Welcome screen */
        .welcome {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--black-deep);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .welcome-title {
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(45deg, var(--primary-teal), var(--primary-light), var(--pink-neon));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 40px;
            text-shadow: 0 0 50px rgba(0, 180, 166, 0.5);
            animation: neonFlicker 2s ease-in-out infinite;
        }
        
        @keyframes neonFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.98; }
        }
        
        .start-btn {
            background: linear-gradient(135deg, var(--primary-teal), var(--primary-light));
            border: none;
            color: var(--black-deep);
            padding: 20px 60px;
            border-radius: 50px;
            font-size: 28px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 10px 40px rgba(0, 180, 166, 0.5);
            animation: btnPulse 2s ease-in-out infinite;
        }
        
        @keyframes btnPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .start-btn:active {
            transform: scale(0.95);
        }
        
        /* Line explosion */
        .line-explosion {
            position: absolute;
            width: 100%;
            height: 30px;
            background: linear-gradient(90deg, transparent, var(--cyan-neon), transparent);
            opacity: 0;
            pointer-events: none;
            z-index: 50;
        }
        
        .line-explosion.show {
            animation: lineExplosion 0.5s ease-out;
        }
        
        @keyframes lineExplosion {
            0% {
                transform: scaleX(0);
                opacity: 0;
            }
            50% {
                transform: scaleX(1);
                opacity: 1;
            }
            100% {
                transform: scaleX(1.2);
                opacity: 0;
            }
        }
        
        /* Floating shapes */
        .neon-shape {
            position: fixed;
            border-radius: 50%;
            filter: blur(100px);
            opacity: 0.3;
            animation: float 15s infinite ease-in-out;
            z-index: -1;
            pointer-events: none;
        }

        .shape1 {
            width: 400px;
            height: 400px;
            background: var(--primary-teal);
            top: -200px;
            left: -200px;
        }

        .shape2 {
            width: 600px;
            height: 600px;
            background: var(--purple-accent);
            bottom: -300px;
            right: -300px;
            animation-delay: 5s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(100px, -100px) scale(1.1); }
            66% { transform: translate(-100px, 100px) scale(0.9); }
        }
        
        @media (max-height: 700px) {
            .top-ui {
                padding: 5px 15px;
            }
            
            .time-display, .score-display {
                padding: 5px 15px;
            }
            
            .time-value, .score-value {
                font-size: 24px;
            }
            
            .time-label, .score-label {
                font-size: 12px;
            }
            
            .canvas-area {
                top: 60px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Neon Grid Background -->
    <div class="neon-grid"></div>
    
    <!-- Floating Shapes -->
    <div class="neon-shape shape1"></div>
    <div class="neon-shape shape2"></div>

    <div id="gameContainer">
        <!-- Top UI -->
        <div class="top-ui">
            <div class="time-display">
                <span class="time-label">TIME</span>
                <span class="time-value" id="timeDisplay">60</span>
            </div>
            <div class="score-display">
                <span class="score-label">SCORE</span>
                <span class="score-value" id="scoreDisplay">0</span>
            </div>
        </div>
        
        <!-- Canvas -->
        <div class="canvas-area">
            <canvas id="gameCanvas"></canvas>
        </div>
        
        <!-- Time bonus popup -->
        <div class="time-bonus" id="timeBonusPopup"></div>
        
        <!-- Welcome screen -->
        <div class="welcome" id="welcomeScreen">
            <h1 class="welcome-title">TETRIS</h1>
            <button class="start-btn" onclick="startGame()">PLAY</button>
        </div>
        
        <!-- Game over -->
        <div class="game-over" id="gameOverScreen">
            <h1 class="game-over-title">GAME OVER</h1>
            <div class="final-score">Score: <span id="finalScore">0</span></div>
            <button class="restart-btn" onclick="restartGame()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // Configuration
        const BOARD_WIDTH = 12;  // Aumentato da 10
        const BOARD_HEIGHT = 22; // Aumentato da 20
        const BLOCK_SIZE = Math.min(
            Math.floor((window.innerWidth - 40) / BOARD_WIDTH),
            Math.floor((window.innerHeight - 200) / BOARD_HEIGHT),
            32  // Ridotto leggermente per adattarsi meglio
        );
        const INITIAL_TIME = 60; // Aumentato da 30 a 60 secondi
        const DROP_SPEED = 800;
        const FAST_DROP_SPEED = 50; // Velocità quando si trascina verso il basso
        
        // Tetromino pieces con colori Notamy
        const PIECES = [
            // I
            {
                shape: [[1,1,1,1]],
                color: '#00d9ff' // primary-light
            },
            // O
            {
                shape: [[1,1],[1,1]],
                color: '#ffab00' // orange-neon
            },
            // T
            {
                shape: [[0,1,0],[1,1,1]],
                color: '#b366ff' // purple-accent
            },
            // S
            {
                shape: [[0,1,1],[1,1,0]],
                color: '#00e676' // green-neon
            },
            // Z
            {
                shape: [[1,1,0],[0,1,1]],
                color: '#ff6b6b' // pink-neon
            },
            // J
            {
                shape: [[1,0,0],[1,1,1]],
                color: '#00cccc' // cyan-deep
            },
            // L
            {
                shape: [[0,0,1],[1,1,1]],
                color: '#00b4a6' // primary-teal
            }
        ];
        
        // Time bonuses - Aumentati per rendere il gioco più facile
        const TIME_BONUSES = {
            1: 5,   // +5 seconds for 1 line (aumentato da 3)
            2: 12,  // +12 seconds for 2 lines (aumentato da 8)
            3: 20,  // +20 seconds for 3 lines (aumentato da 15)
            4: 35   // +35 seconds for 4 lines TETRIS! (aumentato da 25)
        };
        
        // Game state
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let timeLeft = INITIAL_TIME;
        let gameActive = false;
        let dropTimer = 0;
        let lastTime = 0;
        let fastDropping = false;
        let touchStartY = null;
        
        // Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = BOARD_WIDTH * BLOCK_SIZE;
        canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
        
        // Update canvas area size
        document.querySelector('.canvas-area').style.width = canvas.width + 20 + 'px';
        
        // Initialize
        function init() {
            createBoard();
            setupControls();
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('autostart') === 'true') {
                startGame();
            }
        }
        
        // Create board
        function createBoard() {
            board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        }
        
        // Setup controls
        function setupControls() {
            let touchStartX = null;
            let touchStartTime = null;
            
            // Touch controls for canvas
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameActive) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                touchStartX = x;
                touchStartY = y;
                touchStartTime = Date.now();
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!gameActive || touchStartX === null) return;
                
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                
                // Quick tap = rotate
                if (touchDuration < 200) {
                    rotatePiece();
                }
                
                // Reset fast drop
                fastDropping = false;
                
                touchStartX = null;
                touchStartY = null;
            });
            
            // Swipe controls
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameActive || touchStartX === null) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                const deltaX = x - touchStartX;
                const deltaY = y - touchStartY;
                
                // Movimento orizzontale
                if (Math.abs(deltaX) > 30) {
                    movePiece(deltaX > 0 ? 1 : -1, 0);
                    touchStartX = x;
                }
                
                // Movimento verticale - trascinamento verso il basso
                if (deltaY > 20) {
                    fastDropping = true;
                    dropPiece();
                    touchStartY = y;
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                    case 'ArrowDown':
                        dropPiece();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                }
                
                e.preventDefault();
            });
        }
        
        // Create piece
        function createPiece(type) {
            const piece = PIECES[type];
            return {
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0,
                shape: piece.shape,
                color: piece.color,
                type: type
            };
        }
        
        // Get random piece
        function getRandomPiece() {
            return Math.floor(Math.random() * PIECES.length);
        }
        
        // Check collision
        function isValidPosition(piece, offsetX = 0, offsetY = 0) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        if (newX < 0 || newX >= BOARD_WIDTH || 
                            newY >= BOARD_HEIGHT ||
                            (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        // Move piece
        function movePiece(dx, dy) {
            if (isValidPosition(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                return true;
            }
            return false;
        }
        
        // Rotate piece
        function rotatePiece() {
            // Create rotated shape
            const rotated = currentPiece.shape[0].map((_, index) =>
                currentPiece.shape.map(row => row[index]).reverse()
            );
            
            // Save old shape
            const oldShape = currentPiece.shape;
            currentPiece.shape = rotated;
            
            // Check if valid position
            if (!isValidPosition(currentPiece)) {
                // Try wall kicks
                const kicks = [0, -1, 1, -2, 2];
                let validKick = false;
                
                for (let kick of kicks) {
                    if (isValidPosition(currentPiece, kick, 0)) {
                        currentPiece.x += kick;
                        validKick = true;
                        break;
                    }
                }
                
                // If no valid position, revert
                if (!validKick) {
                    currentPiece.shape = oldShape;
                }
            }
            
            // Create rotation effect
            createRotationEffect();
        }
        
        // Drop piece
        function dropPiece() {
            if (!movePiece(0, 1)) {
                lockPiece();
            }
        }
        
        // Hard drop
        function hardDrop() {
            let dropDistance = 0;
            while (movePiece(0, 1)) {
                dropDistance++;
                score += 2;
            }
            lockPiece();
            updateScore();
        }
        
        // Lock piece
        function lockPiece() {
            // Add piece to board
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.type + 1;
                        }
                    }
                }
            }
            
            // Check for completed lines
            const clearedLines = checkLines();
            
            // Create new piece
            currentPiece = createPiece(getRandomPiece());
            
            // Check game over
            if (!isValidPosition(currentPiece)) {
                gameOver();
            }
        }
        
        // Check lines
        function checkLines() {
            const linesToClear = [];
            
            // Find completed lines
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }
            
            if (linesToClear.length > 0) {
                // Add time bonus
                const timeBonus = TIME_BONUSES[linesToClear.length] || 0;
                timeLeft += timeBonus;
                
                // Show time bonus popup
                showTimeBonus(timeBonus, linesToClear.length);
                
                // Update score
                const points = [40, 100, 300, 1200][linesToClear.length - 1];
                score += points;
                updateScore();
                
                // Clear lines with animation
                clearLines(linesToClear);
            }
            
            return linesToClear.length;
        }
        
        // Clear lines
        function clearLines(linesToClear) {
            // Create explosion effect
            linesToClear.forEach(y => {
                createLineExplosion(y);
            });
            
            // Remove lines after animation
            setTimeout(() => {
                linesToClear.forEach(y => {
                    board.splice(y, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                });
            }, 200);
        }
        
        // Show time bonus
        function showTimeBonus(bonus, lines) {
            const popup = document.getElementById('timeBonusPopup');
            const messages = {
                1: 'SINGLE!',
                2: 'DOUBLE!',
                3: 'TRIPLE!',
                4: 'TETRIS!'
            };
            
            popup.innerHTML = `+${bonus}s<br><span style="font-size: 36px">${messages[lines]}</span>`;
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 1500);
        }
        
        // Create effects
        function createRotationEffect() {
            const centerX = (currentPiece.x + currentPiece.shape[0].length / 2) * BLOCK_SIZE;
            const centerY = (currentPiece.y + currentPiece.shape.length / 2) * BLOCK_SIZE;
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                createParticle(centerX, centerY, {
                    vx: Math.cos(angle) * 100,
                    vy: Math.sin(angle) * 100,
                    color: currentPiece.color
                });
            }
        }
        
        function createLineExplosion(y) {
            // Visual explosion
            const explosion = document.createElement('div');
            explosion.className = 'line-explosion show';
            explosion.style.top = (y * BLOCK_SIZE) + 'px';
            document.querySelector('.canvas-area').appendChild(explosion);
            
            setTimeout(() => explosion.remove(), 500);
            
            // Particles
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const px = x * BLOCK_SIZE + BLOCK_SIZE / 2;
                const py = y * BLOCK_SIZE + BLOCK_SIZE / 2;
                
                for (let i = 0; i < 5; i++) {
                    createParticle(px, py, {
                        vx: (Math.random() - 0.5) * 200,
                        vy: -Math.random() * 150 - 50,
                        color: PIECES[board[y][x] - 1]?.color || '#fff'
                    });
                }
            }
        }
        
        function createParticle(x, y, options) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            const rect = document.querySelector('.canvas-area').getBoundingClientRect();
            particle.style.left = rect.left + x + 'px';
            particle.style.top = rect.top + y + 'px';
            particle.style.background = options.color;
            particle.style.boxShadow = `0 0 10px ${options.color}`;
            
            document.getElementById('gameContainer').appendChild(particle);
            
            let posX = 0;
            let posY = 0;
            let opacity = 1;
            
            const animate = () => {
                posX += options.vx * 0.016;
                posY += options.vy * 0.016;
                options.vy += 300 * 0.016; // gravity
                
                opacity -= 0.02;
                
                particle.style.transform = `translate(${posX}px, ${posY}px)`;
                particle.style.opacity = opacity;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                }
            };
            
            requestAnimationFrame(animate);
        }
        
        // Update game
        function update(currentTime) {
            if (!gameActive) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update timer
            timeLeft -= deltaTime / 1000;
            if (timeLeft <= 0) {
                gameOver();
                return;
            }
            
            updateTimer();
            
            // Drop piece
            dropTimer += deltaTime;
            const currentDropSpeed = fastDropping ? FAST_DROP_SPEED : DROP_SPEED;
            
            if (dropTimer >= currentDropSpeed) {
                dropTimer = 0;
                dropPiece();
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid con colori Notamy
            ctx.strokeStyle = 'rgba(0, 180, 166, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw board
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x]) {
                        const piece = PIECES[board[y][x] - 1];
                        drawBlock(x * BLOCK_SIZE, y * BLOCK_SIZE, piece.color);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            drawBlock(
                                (currentPiece.x + x) * BLOCK_SIZE,
                                (currentPiece.y + y) * BLOCK_SIZE,
                                currentPiece.color,
                                true
                            );
                        }
                    }
                }
                
                // Draw ghost piece (preview where piece will land)
                drawGhostPiece();
            }
        }
        
        // Draw ghost piece
        function drawGhostPiece() {
            const ghost = {
                ...currentPiece,
                y: currentPiece.y
            };
            
            // Move ghost down until collision
            while (isValidPosition(ghost, 0, 1)) {
                ghost.y++;
            }
            
            // Draw ghost
            ctx.save();
            ctx.globalAlpha = 0.2;
            for (let y = 0; y < ghost.shape.length; y++) {
                for (let x = 0; x < ghost.shape[y].length; x++) {
                    if (ghost.shape[y][x]) {
                        drawBlock(
                            (ghost.x + x) * BLOCK_SIZE,
                            (ghost.y + y) * BLOCK_SIZE,
                            ghost.color
                        );
                    }
                }
            }
            ctx.restore();
        }
        
        // Draw block con stile Notamy
        function drawBlock(x, y, color, active = false) {
            const padding = 2;
            const bx = x + padding;
            const by = y + padding;
            const size = BLOCK_SIZE - padding * 2;
            
            // Glow effect
            if (active) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
            }
            
            // Main block con gradiente
            const gradient = ctx.createLinearGradient(bx, by, bx + size, by + size);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, shadeColor(color, 20));
            gradient.addColorStop(1, shadeColor(color, -20));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(bx, by, size, size);
            
            // Neon border
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.strokeRect(bx, by, size, size);
            
            // Inner glow
            const innerGradient = ctx.createRadialGradient(
                bx + size/2, by + size/2, 0,
                bx + size/2, by + size/2, size/2
            );
            innerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = innerGradient;
            ctx.fillRect(bx, by, size, size);
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(bx + 2, by + 2, size - 4, 2);
            ctx.fillRect(bx + 2, by + 2, 2, size - 4);
            
            ctx.shadowBlur = 0;
        }
        
        // Shade color
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        // Update UI
        function updateTimer() {
            const display = document.getElementById('timeDisplay');
            display.textContent = Math.ceil(timeLeft);
            
            if (timeLeft < 10) {
                display.style.color = var(--pink-neon);
                display.style.animation = 'pulse 0.5s ease-in-out infinite';
            } else {
                display.style.color = var(--white);
                display.style.animation = 'none';
            }
        }
        
        function updateScore() {
            document.getElementById('scoreDisplay').textContent = score.toLocaleString();
        }
        
        // Game functions
        function startGame() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Reset game
            createBoard();
            score = 0;
            timeLeft = INITIAL_TIME;
            dropTimer = 0;
            gameActive = true;
            fastDropping = false;
            
            // Create first piece
            currentPiece = createPiece(getRandomPiece());
            
            // Update UI
            updateScore();
            
            // Start game loop
            lastTime = performance.now();
            requestAnimationFrame(update);
        }
        
        function gameOver() {
            gameActive = false;
            
            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            // Save best score
            const best = localStorage.getItem('tetrisBest') || 0;
            if (score > best) {
                localStorage.setItem('tetrisBest', score);
            }
        }
        
        function restartGame() {
            startGame();
        }
        
        // Initialize
        init();
    </script>
</body>
</html>
