<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>NOTAMY TETRIS - ULTIMATE EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        :root {
            --primary-teal: #00b4a6;
            --primary-light: #00d9ff;
            --cyan-neon: #00ffff;
            --cyan-deep: #00cccc;
            --cyan-light: #7affff;
            --purple-accent: #b366ff;
            --pink-neon: #ff6b6b;
            --orange-neon: #ffab00;
            --green-neon: #00e676;
            --yellow-neon: #ffeb3b;
            --red-glow: #ff5252;
            --blue-electric: #448aff;
            --indigo-deep: #3f51b5;
            --black-deep: #000000;
            --black-soft: #0a0a0a;
            --gray-dark: #1a1a1a;
            --gray-medium: #2a2a2a;
            --white: #ffffff;
            --gradient-main: linear-gradient(135deg, #00b4a6, #00d9ff);
            --gradient-fire: linear-gradient(135deg, #ff6b6b, #ffab00);
            --gradient-ice: linear-gradient(135deg, #00d9ff, #00ffff);
            --gradient-nature: linear-gradient(135deg, #00e676, #00b4a6);
            --gradient-cosmic: linear-gradient(135deg, #b366ff, #448aff);
            --gradient-sunset: linear-gradient(135deg, #ff6b6b, #ff5252);
        }
        
        body {
            background: var(--black-deep);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        /* BACKGROUND EFFECTS */
        .background-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -10;
            overflow: hidden;
        }
        
        /* Neon Grid Background */
        .neon-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 180, 166, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 180, 166, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        /* Dynamic Background Particles */
        .particle-field {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .bg-particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }
        
        @keyframes float-up {
            0% {
                transform: translateY(100vh) translateX(0) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.8;
                transform: translateY(90vh) translateX(10px) scale(1) rotate(90deg);
            }
            90% {
                opacity: 0.8;
                transform: translateY(10vh) translateX(-10px) scale(1) rotate(270deg);
            }
            100% {
                transform: translateY(-10vh) translateX(20px) scale(0.5) rotate(360deg);
                opacity: 0;
            }
        }
        
        @keyframes pulse-glow {
            0%, 100% { 
                transform: scale(1);
                opacity: 0.5;
            }
            50% { 
                transform: scale(1.5);
                opacity: 0.8;
            }
        }
        
        /* Floating Orbs */
        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(40px);
            animation: orb-float 20s ease-in-out infinite;
        }
        
        .orb1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, var(--primary-teal) 0%, transparent 70%);
            top: -150px;
            left: -150px;
            animation-duration: 25s;
        }
        
        .orb2 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, var(--purple-accent) 0%, transparent 70%);
            bottom: -200px;
            right: -200px;
            animation-duration: 30s;
            animation-delay: 5s;
        }
        
        .orb3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, var(--pink-neon) 0%, transparent 70%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation-duration: 20s;
            animation-delay: 10s;
        }
        
        @keyframes orb-float {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                opacity: 0.3;
            }
            25% { 
                transform: translate(100px, -100px) scale(1.2);
                opacity: 0.5;
            }
            50% { 
                transform: translate(-50px, 100px) scale(0.8);
                opacity: 0.4;
            }
            75% { 
                transform: translate(-100px, -50px) scale(1.1);
                opacity: 0.6;
            }
        }
        
        /* Lightning Effects */
        .lightning {
            position: absolute;
            width: 2px;
            height: 100vh;
            background: linear-gradient(to bottom, transparent, var(--cyan-neon), transparent);
            opacity: 0;
            animation: lightning-strike 8s infinite;
        }
        
        @keyframes lightning-strike {
            0%, 95%, 100% { 
                opacity: 0;
                transform: translateX(0) scaleX(1);
            }
            96% { 
                opacity: 1;
                transform: translateX(0) scaleX(1);
            }
            97% { 
                opacity: 0.8;
                transform: translateX(-50px) scaleX(2);
            }
            98% { 
                opacity: 1;
                transform: translateX(50px) scaleX(1.5);
            }
        }
        
        /* GAME CONTAINER */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* TOP UI */
        .top-ui {
            position: absolute;
            top: env(safe-area-inset-top, 10px);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            z-index: 100;
        }
        
        /* Score & Level Display */
        .info-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-teal);
            border-radius: 20px;
            padding: 8px 20px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(0, 180, 166, 0.5),
                inset 0 0 20px rgba(0, 180, 166, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .info-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--gradient-main);
            border-radius: 20px;
            opacity: 0;
            animation: panel-glow 3s ease-in-out infinite;
            z-index: -1;
        }
        
        @keyframes panel-glow {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.5; }
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .info-label {
            font-size: 11px;
            color: var(--primary-teal);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }
        
        .info-value {
            font-size: 24px;
            font-weight: 900;
            color: var(--white);
            text-shadow: 0 0 20px currentColor;
            transition: all 0.3s ease;
        }
        
        .info-value.pulse {
            animation: value-pulse 0.5s ease;
        }
        
        @keyframes value-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: var(--cyan-neon); }
            100% { transform: scale(1); }
        }
        
        /* Timer Display */
        .timer-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--pink-neon);
            border-radius: 20px;
            padding: 8px 20px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(255, 107, 107, 0.5),
                inset 0 0 20px rgba(255, 107, 107, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .timer-display.critical {
            animation: timer-critical 0.5s ease-in-out infinite;
        }
        
        @keyframes timer-critical {
            0%, 100% { 
                border-color: var(--pink-neon);
                box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            }
            50% { 
                border-color: var(--red-glow);
                box-shadow: 0 0 50px rgba(255, 82, 82, 0.8);
            }
        }
        
        .timer-icon {
            width: 24px;
            height: 24px;
            fill: var(--pink-neon);
            animation: timer-tick 1s steps(12) infinite;
        }
        
        @keyframes timer-tick {
            to { transform: rotate(360deg); }
        }
        
        .timer-value {
            font-size: 28px;
            font-weight: 900;
            color: var(--white);
            text-shadow: 0 0 20px var(--pink-neon);
            min-width: 50px;
            text-align: center;
        }
        
        /* GAME AREA */
        .game-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
        
        /* Left Panel - Hold & Stats */
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Hold Box */
        .hold-box {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--purple-accent);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(179, 102, 255, 0.5),
                inset 0 0 20px rgba(179, 102, 255, 0.1);
            position: relative;
        }
        
        .hold-label {
            font-size: 12px;
            color: var(--purple-accent);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .hold-canvas {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        /* Statistics Panel */
        .stats-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--green-neon);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(0, 230, 118, 0.5),
                inset 0 0 20px rgba(0, 230, 118, 0.1);
            min-width: 120px;
        }
        
        .stats-title {
            font-size: 12px;
            color: var(--green-neon);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .stat-value {
            color: var(--white);
            font-weight: 700;
            text-shadow: 0 0 10px currentColor;
        }
        
        /* Main Game Board */
        .board-container {
            position: relative;
        }
        
        .canvas-area {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid var(--primary-teal);
            border-radius: 20px;
            padding: 10px;
            box-shadow: 
                0 0 50px rgba(0, 180, 166, 0.5),
                inset 0 0 30px rgba(0, 180, 166, 0.1);
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }
        
        .canvas-area::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(
                from 0deg,
                transparent,
                var(--primary-teal),
                transparent,
                var(--primary-light),
                transparent
            );
            animation: board-rotate 10s linear infinite;
            opacity: 0.1;
        }
        
        @keyframes board-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 20, 0.95) 100%);
            border-radius: 10px;
            position: relative;
            z-index: 1;
        }
        
        /* Right Panel - Next & Level */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Next Box */
        .next-box {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--orange-neon);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(255, 171, 0, 0.5),
                inset 0 0 20px rgba(255, 171, 0, 0.1);
        }
        
        .next-label {
            font-size: 12px;
            color: var(--orange-neon);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .next-canvas {
            width: 100px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }
        
        /* Level Progress */
        .level-progress {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--blue-electric);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 30px rgba(68, 138, 255, 0.5),
                inset 0 0 20px rgba(68, 138, 255, 0.1);
        }
        
        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .level-label {
            font-size: 12px;
            color: var(--blue-electric);
            font-weight: 700;
        }
        
        .level-value {
            font-size: 18px;
            color: var(--white);
            font-weight: 900;
            text-shadow: 0 0 15px var(--blue-electric);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--gradient-ice);
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--cyan-neon);
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            animation: progress-shine 2s ease-in-out infinite;
        }
        
        @keyframes progress-shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        /* EFFECTS OVERLAY */
        .effects-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
        }
        
        /* Combo Display */
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 900;
            color: var(--yellow-neon);
            text-shadow: 
                0 0 30px currentColor,
                0 0 60px currentColor;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            text-align: center;
        }
        
        .combo-display.show {
            animation: combo-popup 1.5s ease-out;
        }
        
        @keyframes combo-popup {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0) rotate(-180deg);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1) translateY(-100px);
            }
        }
        
        /* Line Clear Effect */
        .line-clear-effect {
            position: absolute;
            width: 100%;
            height: 30px;
            pointer-events: none;
            z-index: 150;
        }
        
        .line-flash {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                var(--cyan-neon), 
                var(--white), 
                var(--cyan-neon), 
                transparent
            );
            opacity: 0;
            animation: line-flash-anim 0.6s ease-out;
        }
        
        @keyframes line-flash-anim {
            0% {
                transform: scaleX(0);
                opacity: 0;
            }
            50% {
                transform: scaleX(1);
                opacity: 1;
            }
            100% {
                transform: scaleX(1.2);
                opacity: 0;
            }
        }
        
        /* Particle System */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 250;
        }
        
        .particle-spark {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
        }
        
        .particle-star {
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            border-bottom: 6px solid currentColor;
            filter: drop-shadow(0 0 6px currentColor);
        }
        
        .particle-ring {
            width: 20px;
            height: 20px;
            border: 2px solid currentColor;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
        }
        
        /* Power-up Effects */
        .powerup-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 180;
        }
        
        .powerup-wave {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 3px solid var(--green-neon);
            border-radius: 50%;
            opacity: 0;
            animation: powerup-wave-anim 1s ease-out;
        }
        
        @keyframes powerup-wave-anim {
            0% {
                width: 100px;
                height: 100px;
                opacity: 1;
            }
            100% {
                width: 500px;
                height: 500px;
                opacity: 0;
            }
        }
        
        /* Achievement Popup */
        .achievement-popup {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--yellow-neon);
            border-radius: 20px;
            padding: 20px 40px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 50px rgba(255, 235, 59, 0.5),
                inset 0 0 30px rgba(255, 235, 59, 0.1);
            opacity: 0;
            pointer-events: none;
            z-index: 500;
        }
        
        .achievement-popup.show {
            animation: achievement-show 3s ease-out;
        }
        
        @keyframes achievement-show {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1.1);
            }
            30% {
                transform: translateX(-50%) translateY(0) scale(1);
            }
            70% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-50px) scale(0.8);
            }
        }
        
        .achievement-icon {
            font-size: 48px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .achievement-title {
            font-size: 18px;
            font-weight: 900;
            color: var(--yellow-neon);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .achievement-desc {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }
        
        /* GAME OVER SCREEN */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }
        
        .game-over-content {
            text-align: center;
            animation: game-over-fade 0.5s ease-out;
        }
        
        @keyframes game-over-fade {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .game-over-title {
            font-size: 64px;
            font-weight: 900;
            background: linear-gradient(45deg, var(--pink-neon), var(--orange-neon));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            text-shadow: 0 0 80px rgba(255, 107, 107, 0.5);
            animation: title-pulse 2s ease-in-out infinite;
        }
        
        @keyframes title-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .final-stats {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--primary-teal);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 50px rgba(0, 180, 166, 0.3);
        }
        
        .final-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .final-stat {
            text-align: center;
        }
        
        .final-stat-label {
            font-size: 14px;
            color: var(--primary-teal);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }
        
        .final-stat-value {
            font-size: 32px;
            font-weight: 900;
            color: var(--white);
            text-shadow: 0 0 20px currentColor;
        }
        
        .new-record {
            font-size: 18px;
            color: var(--yellow-neon);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: record-blink 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes record-blink {
            from { opacity: 0.5; }
            to { opacity: 1; }
        }
        
        .game-over-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        
        .game-button {
            background: var(--gradient-main);
            border: none;
            color: var(--black-deep);
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(0, 180, 166, 0.5);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .game-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .game-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0, 180, 166, 0.7);
        }
        
        .game-button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .game-button:active {
            transform: translateY(-1px);
        }
        
        /* PAUSE MENU */
        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 900;
            backdrop-filter: blur(10px);
        }
        
        .pause-title {
            font-size: 48px;
            font-weight: 900;
            color: var(--cyan-neon);
            margin-bottom: 40px;
            text-shadow: 0 0 40px currentColor;
        }
        
        .pause-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* WELCOME SCREEN */
        .welcome {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--black-deep);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .welcome-content {
            text-align: center;
            animation: welcome-intro 1s ease-out;
        }
        
        @keyframes welcome-intro {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .welcome-logo {
            font-size: 120px;
            font-weight: 200;
            background: linear-gradient(45deg, var(--primary-teal), var(--primary-light), var(--purple-accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            animation: logo-float 3s ease-in-out infinite;
            position: relative;
        }
        
        @keyframes logo-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .welcome-subtitle {
            font-size: 24px;
            font-weight: 300;
            color: var(--primary-light);
            margin-bottom: 60px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.8;
        }
        
        .play-button {
            background: var(--gradient-main);
            border: none;
            color: var(--black-deep);
            padding: 20px 80px;
            border-radius: 50px;
            font-size: 32px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 20px 60px rgba(0, 180, 166, 0.5);
            animation: play-pulse 2s ease-in-out infinite;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        @keyframes play-pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 20px 60px rgba(0, 180, 166, 0.5);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 25px 80px rgba(0, 180, 166, 0.7);
            }
        }
        
        .play-button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }
        
        .play-button:hover::after {
            animation: button-shine 0.5s ease-out;
        }
        
        @keyframes button-shine {
            from { left: -50%; }
            to { left: 150%; }
        }
        
        .play-button:active {
            transform: scale(0.95);
        }
        
        /* CONTROLS HINT */
        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 180, 166, 0.3);
            border-radius: 20px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .controls-hint:hover {
            opacity: 1;
        }
        
        .controls-title {
            font-size: 12px;
            color: var(--primary-teal);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-key {
            background: rgba(0, 180, 166, 0.2);
            border: 1px solid rgba(0, 180, 166, 0.5);
            border-radius: 5px;
            padding: 3px 8px;
            font-weight: 700;
            color: var(--primary-teal);
        }
        
        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .left-panel, .right-panel {
                flex-direction: row;
                gap: 15px;
            }
            
            .welcome-logo {
                font-size: 80px;
            }
            
            .welcome-subtitle {
                font-size: 18px;
            }
            
            .play-button {
                font-size: 24px;
                padding: 15px 60px;
            }
            
            .controls-hint {
                display: none;
            }
        }
        
        @media (max-height: 700px) {
            .top-ui {
                padding: 5px 15px;
            }
            
            .info-panel, .timer-display {
                padding: 5px 15px;
            }
            
            .info-value {
                font-size: 20px;
            }
            
            .timer-value {
                font-size: 24px;
            }
            
            .canvas-area {
                padding: 8px;
            }
        }
        
        /* SPECIAL EFFECTS */
        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--white);
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
        }
        
        .screen-flash.active {
            animation: screen-flash-anim 0.3s ease-out;
        }
        
        @keyframes screen-flash-anim {
            0% { opacity: 0; }
            50% { opacity: 0.5; }
            100% { opacity: 0; }
        }
        
        .screen-shake {
            animation: screen-shake-anim 0.5s ease-out;
        }
        
        @keyframes screen-shake-anim {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5px, 5px); }
            20% { transform: translate(5px, -5px); }
            30% { transform: translate(-3px, 3px); }
            40% { transform: translate(3px, -3px); }
            50% { transform: translate(-2px, 2px); }
            60% { transform: translate(2px, -2px); }
            70% { transform: translate(-1px, 1px); }
            80% { transform: translate(1px, -1px); }
            90% { transform: translate(0, 0); }
        }
    </style>
</head>
<body>
    <!-- Background Container -->
    <div class="background-container">
        <div class="neon-grid"></div>
        <div class="particle-field" id="particleField"></div>
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
        <div class="lightning" style="left: 20%;"></div>
        <div class="lightning" style="left: 80%; animation-delay: 4s;"></div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <!-- Top UI -->
        <div class="top-ui">
            <div class="info-panel">
                <div class="info-item">
                    <span class="info-label">SCORE</span>
                    <span class="info-value" id="scoreDisplay">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">LEVEL</span>
                    <span class="info-value" id="levelDisplay">1</span>
                </div>
                <div class="info-item">
                    <span class="info-label">LINES</span>
                    <span class="info-value" id="linesDisplay">0</span>
                </div>
            </div>
            
            <div class="timer-display" id="timerDisplay">
                <svg class="timer-icon" viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/>
                </svg>
                <span class="timer-value" id="timeValue">60</span>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area">
            <!-- Left Panel -->
            <div class="left-panel">
                <div class="hold-box">
                    <div class="hold-label">HOLD</div>
                    <canvas class="hold-canvas" id="holdCanvas"></canvas>
                </div>
                
                <div class="stats-panel">
                    <div class="stats-title">STATS</div>
                    <div class="stat-item">
                        <span class="stat-label">T-Spins:</span>
                        <span class="stat-value" id="tspinStat">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Combos:</span>
                        <span class="stat-value" id="comboStat">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">B2B:</span>
                        <span class="stat-value" id="b2bStat">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Tetris:</span>
                        <span class="stat-value" id="tetrisStat">0</span>
                    </div>
                </div>
            </div>
            
            <!-- Main Board -->
            <div class="board-container">
                <div class="canvas-area">
                    <canvas id="gameCanvas"></canvas>
                </div>
            </div>
            
            <!-- Right Panel -->
            <div class="right-panel">
                <div class="next-box">
                    <div class="next-label">NEXT</div>
                    <canvas class="next-canvas" id="nextCanvas1"></canvas>
                    <canvas class="next-canvas" id="nextCanvas2"></canvas>
                    <canvas class="next-canvas" id="nextCanvas3"></canvas>
                </div>
                
                <div class="level-progress">
                    <div class="level-info">
                        <span class="level-label">LEVEL</span>
                        <span class="level-value" id="levelProgressValue">1</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Effects Overlay -->
        <div class="effects-overlay" id="effectsOverlay"></div>
        
        <!-- Combo Display -->
        <div class="combo-display" id="comboDisplay"></div>
        
        <!-- Achievement Popup -->
        <div class="achievement-popup" id="achievementPopup">
            <div class="achievement-icon" id="achievementIcon">🏆</div>
            <div class="achievement-title" id="achievementTitle">Achievement!</div>
            <div class="achievement-desc" id="achievementDesc">Description</div>
        </div>
        
        <!-- Welcome Screen -->
        <div class="welcome" id="welcomeScreen">
            <div class="welcome-content">
                <h1 class="welcome-logo">TETRIS</h1>
                <p class="welcome-subtitle">Ultimate Edition</p>
                <button class="play-button" onclick="startGame()">PLAY</button>
            </div>
            <div class="controls-hint">
                <div class="controls-title">Controls</div>
                <div class="controls-grid">
                    <div class="control-item">
                        <span class="control-key">←→</span>
                        <span>Move</span>
                    </div>
                    <div class="control-item">
                        <span class="control-key">↑</span>
                        <span>Rotate</span>
                    </div>
                    <div class="control-item">
                        <span class="control-key">↓</span>
                        <span>Soft Drop</span>
                    </div>
                    <div class="control-item">
                        <span class="control-key">Space</span>
                        <span>Hard Drop</span>
                    </div>
                    <div class="control-item">
                        <span class="control-key">C</span>
                        <span>Hold</span>
                    </div>
                    <div class="control-item">
                        <span class="control-key">P</span>
                        <span>Pause</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Pause Menu -->
        <div class="pause-menu" id="pauseMenu">
            <h2 class="pause-title">PAUSED</h2>
            <div class="pause-options">
                <button class="game-button" onclick="resumeGame()">RESUME</button>
                <button class="game-button" onclick="restartGame()">RESTART</button>
                <button class="game-button" onclick="quitGame()">QUIT</button>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div class="game-over" id="gameOverScreen">
            <div class="game-over-content">
                <h1 class="game-over-title">GAME OVER</h1>
                <div class="final-stats">
                    <div class="final-stat-grid">
                        <div class="final-stat">
                            <div class="final-stat-label">Final Score</div>
                            <div class="final-stat-value" id="finalScore">0</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-label">Level Reached</div>
                            <div class="final-stat-value" id="finalLevel">1</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-label">Lines Cleared</div>
                            <div class="final-stat-value" id="finalLines">0</div>
                        </div>
                        <div class="final-stat">
                            <div class="final-stat-label">Play Time</div>
                            <div class="final-stat-value" id="finalTime">0:00</div>
                        </div>
                    </div>
                    <div class="new-record" id="newRecord" style="display: none;">NEW RECORD!</div>
                </div>
                <div class="game-over-buttons">
                    <button class="game-button" onclick="restartGame()">PLAY AGAIN</button>
                    <button class="game-button" onclick="showMainMenu()">MAIN MENU</button>
                </div>
            </div>
        </div>
        
        <!-- Screen Flash Effect -->
        <div class="screen-flash" id="screenFlash"></div>
    </div>

    <script>
        // ==================== GAME CONSTANTS ====================
        const BOARD_WIDTH = 12;
        const BOARD_HEIGHT = 22;
        const VISIBLE_HEIGHT = 20;
        const BLOCK_SIZE = Math.min(
            Math.floor((window.innerWidth - 200) / BOARD_WIDTH),
            Math.floor((window.innerHeight - 250) / VISIBLE_HEIGHT),
            30
        );
        
        // Timing Constants
        const INITIAL_TIME = 60;
        const BASE_DROP_SPEED = 800;
        const SOFT_DROP_SPEED = 50;
        const LOCK_DELAY = 500;
        const LINE_CLEAR_DELAY = 300;
        const DAS_DELAY = 170;
        const ARR_DELAY = 50;
        
        // Scoring Constants
        const SCORE_SINGLE = 100;
        const SCORE_DOUBLE = 300;
        const SCORE_TRIPLE = 500;
        const SCORE_TETRIS = 800;
        const SCORE_TSPIN = 400;
        const SCORE_TSPIN_SINGLE = 800;
        const SCORE_TSPIN_DOUBLE = 1200;
        const SCORE_TSPIN_TRIPLE = 1600;
        const SCORE_SOFT_DROP = 1;
        const SCORE_HARD_DROP = 2;
        const COMBO_MULTIPLIER = 50;
        const B2B_MULTIPLIER = 1.5;
        
        // Level Constants
        const LINES_PER_LEVEL = 10;
        const MAX_LEVEL = 20;
        const SPEED_CURVE = [
            1000, 900, 800, 700, 600,
            500, 400, 300, 250, 200,
            180, 160, 140, 120, 100,
            90, 80, 70, 60, 50
        ];
        
        // Time Bonuses
        const TIME_BONUSES = {
            1: 5,
            2: 12,
            3: 20,
            4: 35,
            tspin: 15,
            combo: 3,
            levelup: 10
        };
        
        // Tetromino Definitions
        const PIECES = [
            {
                name: 'I',
                shape: [
                    [0,0,0,0],
                    [1,1,1,1],
                    [0,0,0,0],
                    [0,0,0,0]
                ],
                color: '#00d9ff',
                glow: 'rgba(0, 217, 255, 0.6)',
                center: [1.5, 1.5]
            },
            {
                name: 'O',
                shape: [
                    [1,1],
                    [1,1]
                ],
                color: '#ffab00',
                glow: 'rgba(255, 171, 0, 0.6)',
                center: [0.5, 0.5]
            },
            {
                name: 'T',
                shape: [
                    [0,1,0],
                    [1,1,1],
                    [0,0,0]
                ],
                color: '#b366ff',
                glow: 'rgba(179, 102, 255, 0.6)',
                center: [1, 1]
            },
            {
                name: 'S',
                shape: [
                    [0,1,1],
                    [1,1,0],
                    [0,0,0]
                ],
                color: '#00e676',
                glow: 'rgba(0, 230, 118, 0.6)',
                center: [1, 1]
            },
            {
                name: 'Z',
                shape: [
                    [1,1,0],
                    [0,1,1],
                    [0,0,0]
                ],
                color: '#ff6b6b',
                glow: 'rgba(255, 107, 107, 0.6)',
                center: [1, 1]
            },
            {
                name: 'J',
                shape: [
                    [1,0,0],
                    [1,1,1],
                    [0,0,0]
                ],
                color: '#448aff',
                glow: 'rgba(68, 138, 255, 0.6)',
                center: [1, 1]
            },
            {
                name: 'L',
                shape: [
                    [0,0,1],
                    [1,1,1],
                    [0,0,0]
                ],
                color: '#00b4a6',
                glow: 'rgba(0, 180, 166, 0.6)',
                center: [1, 1]
            }
        ];
        
        // Wall Kick Data (SRS)
        const WALL_KICKS = {
            normal: {
                '0->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
                '1->0': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
                '1->2': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
                '2->1': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
                '2->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
                '3->2': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
                '3->0': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
                '0->3': [[0,0], [1,0], [1,1], [0,-2], [1,-2]]
            },
            I: {
                '0->1': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
                '1->0': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
                '1->2': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]],
                '2->1': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
                '2->3': [[0,0], [2,0], [-1,0], [2,1], [-1,-2]],
                '3->2': [[0,0], [-2,0], [1,0], [-2,-1], [1,2]],
                '3->0': [[0,0], [1,0], [-2,0], [1,-2], [-2,1]],
                '0->3': [[0,0], [-1,0], [2,0], [-1,2], [2,-1]]
            }
        };
        
        // Achievement Definitions
        const ACHIEVEMENTS = {
            firstTetris: {
                id: 'firstTetris',
                title: 'Tetris Master',
                desc: 'Clear your first Tetris!',
                icon: '🎯'
            },
            speedDemon: {
                id: 'speedDemon',
                title: 'Speed Demon',
                desc: 'Reach level 10!',
                icon: '⚡'
            },
            comboKing: {
                id: 'comboKing',
                title: 'Combo King',
                desc: 'Achieve a 10x combo!',
                icon: '🔥'
            },
            tspinMaster: {
                id: 'tspinMaster',
                title: 'T-Spin Master',
                desc: 'Perform 5 T-Spins!',
                icon: '🌀'
            },
            survivor: {
                id: 'survivor',
                title: 'Survivor',
                desc: 'Play for 5 minutes!',
                icon: '⏱️'
            },
            scoreHunter: {
                id: 'scoreHunter',
                title: 'Score Hunter',
                desc: 'Reach 10,000 points!',
                icon: '💎'
            },
            perfectClear: {
                id: 'perfectClear',
                title: 'Perfect Clear',
                desc: 'Clear the entire board!',
                icon: '✨'
            }
        };
        
        // ==================== GAME STATE ====================
        let gameState = {
            // Board
            board: [],
            
            // Current Piece
            currentPiece: null,
            currentX: 0,
            currentY: 0,
            currentRotation: 0,
            
            // Next Pieces
            nextPieces: [],
            bag: [],
            
            // Hold Piece
            holdPiece: null,
            canHold: true,
            
            // Game Status
            gameActive: false,
            gamePaused: false,
            gameStartTime: 0,
            
            // Scoring
            score: 0,
            level: 1,
            lines: 0,
            
            // Time
            timeLeft: INITIAL_TIME,
            
            // Drop Mechanics
            dropTimer: 0,
            lockTimer: 0,
            softDropping: false,
            
            // Movement
            dasTimer: 0,
            arrTimer: 0,
            currentDAS: null,
            
            // Combos & Bonuses
            combo: 0,
            b2b: false,
            lastClearWasSpecial: false,
            
            // Statistics
            stats: {
                tspins: 0,
                maxCombo: 0,
                tetrisCount: 0,
                totalPieces: 0,
                piecesPerType: [0, 0, 0, 0, 0, 0, 0]
            },
            
            // Achievements
            unlockedAchievements: new Set(),
            
            // Effects
            linesClearingAnimation: false,
            
            // High Score
            highScore: parseInt(localStorage.getItem('tetrisHighScore') || '0')
        };
        
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = BOARD_WIDTH * BLOCK_SIZE;
        canvas.height = VISIBLE_HEIGHT * BLOCK_SIZE;
        
        const holdCanvas = document.getElementById('holdCanvas');
        const holdCtx = holdCanvas.getContext('2d');
        holdCanvas.width = 80;
        holdCanvas.height = 80;
        
        const nextCanvases = [
            document.getElementById('nextCanvas1'),
            document.getElementById('nextCanvas2'),
            document.getElementById('nextCanvas3')
        ];
        const nextContexts = nextCanvases.map(c => {
            c.width = 100;
            c.height = 80;
            return c.getContext('2d');
        });
        
        // Update canvas area size
        document.querySelector('.canvas-area').style.width = canvas.width + 20 + 'px';
        document.querySelector('.canvas-area').style.height = canvas.height + 20 + 'px';
        
        // ==================== INITIALIZATION ====================
        function init() {
            createBoard();
            setupControls();
            createBackgroundParticles();
            loadHighScore();
            
            // Check for autostart
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('autostart') === 'true') {
                startGame();
            }
        }
        
        function createBoard() {
            gameState.board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        }
        
        function createBackgroundParticles() {
            const particleField = document.getElementById('particleField');
            const colors = ['#00b4a6', '#00d9ff', '#ff6b6b', '#00e676', '#b366ff', '#ffab00'];
            
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'bg-particle';
                particle.style.width = particle.style.height = Math.random() * 4 + 2 + 'px';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px currentColor`;
                particle.style.animation = 'float-up ' + particle.style.animationDuration + ' linear infinite';
                particleField.appendChild(particle);
            }
        }
        
        function loadHighScore() {
            gameState.highScore = parseInt(localStorage.getItem('tetrisHighScore') || '0');
        }
        
        // ==================== CONTROLS ====================
        function setupControls() {
            // Keyboard Controls
            const keyState = {};
            
            document.addEventListener('keydown', (e) => {
                if (!gameState.gameActive || gameState.gamePaused) {
                    if (e.key === 'p' || e.key === 'P') {
                        togglePause();
                    }
                    return;
                }
                
                if (keyState[e.key]) return;
                keyState[e.key] = true;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        startDAS('left');
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        startDAS('right');
                        movePiece(1, 0);
                        break;
                    case 'ArrowUp':
                        rotatePiece(1);
                        break;
                    case 'z':
                    case 'Z':
                        rotatePiece(-1);
                        break;
                    case 'ArrowDown':
                        gameState.softDropping = true;
                        break;
                    case ' ':
                        hardDrop();
                        break;
                    case 'c':
                    case 'C':
                        holdPiece();
                        break;
                    case 'p':
                    case 'P':
                        togglePause();
                        break;
                }
                
                e.preventDefault();
            });
            
            document.addEventListener('keyup', (e) => {
                keyState[e.key] = false;
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    stopDAS();
                }
                if (e.key === 'ArrowDown') {
                    gameState.softDropping = false;
                }
            });
            
            // Touch Controls
            let touchStartX = null;
            let touchStartY = null;
            let touchStartTime = null;
            let lastTouchX = null;
            
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameState.gameActive || gameState.gamePaused) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                touchStartX = touch.clientX - rect.left;
                touchStartY = touch.clientY - rect.top;
                lastTouchX = touchStartX;
                touchStartTime = Date.now();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!gameState.gameActive || gameState.gamePaused || touchStartX === null) return;
                
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const currentX = touch.clientX - rect.left;
                const currentY = touch.clientY - rect.top;
                
                const deltaX = currentX - lastTouchX;
                const deltaY = currentY - touchStartY;
                
                // Horizontal movement
                if (Math.abs(deltaX) > 30) {
                    movePiece(deltaX > 0 ? 1 : -1, 0);
                    lastTouchX = currentX;
                }
                
                // Vertical movement - fast drop
                if (deltaY > 50) {
                    gameState.softDropping = true;
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!gameState.gameActive || gameState.gamePaused || touchStartX === null) return;
                
                const touchDuration = Date.now() - touchStartTime;
                const touch = e.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const endX = touch.clientX - rect.left;
                const endY = touch.clientY - rect.top;
                
                const deltaX = endX - touchStartX;
                const deltaY = endY - touchStartY;
                
                // Quick tap = rotate
                if (touchDuration < 200 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
                    rotatePiece(1);
                }
                // Swipe up = hard drop
                else if (deltaY < -50 && Math.abs(deltaX) < 50) {
                    hardDrop();
                }
                
                gameState.softDropping = false;
                touchStartX = null;
                touchStartY = null;
                touchStartTime = null;
                lastTouchX = null;
            });
            
            // Double tap for hold
            let lastTapTime = 0;
            canvas.addEventListener('touchstart', (e) => {
                const currentTime = Date.now();
                if (currentTime - lastTapTime < 300) {
                    holdPiece();
                    e.preventDefault();
                }
                lastTapTime = currentTime;
            });
        }
        
        // DAS (Delayed Auto Shift) System
        function startDAS(direction) {
            gameState.currentDAS = direction;
            gameState.dasTimer = 0;
            gameState.arrTimer = 0;
        }
        
        function stopDAS() {
            gameState.currentDAS = null;
            gameState.dasTimer = 0;
            gameState.arrTimer = 0;
        }
        
        function updateDAS(deltaTime) {
            if (!gameState.currentDAS) return;
            
            gameState.dasTimer += deltaTime;
            
            if (gameState.dasTimer >= DAS_DELAY) {
                gameState.arrTimer += deltaTime;
                
                if (gameState.arrTimer >= ARR_DELAY) {
                    const direction = gameState.currentDAS === 'left' ? -1 : 1;
                    movePiece(direction, 0);
                    gameState.arrTimer = 0;
                }
            }
        }
        
        // ==================== PIECE GENERATION ====================
        function generateBag() {
            const bag = [0, 1, 2, 3, 4, 5, 6];
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
            return bag;
        }
        
        function getNextPiece() {
            if (gameState.bag.length === 0) {
                gameState.bag = generateBag();
            }
            return gameState.bag.pop();
        }
        
        function fillNextQueue() {
            while (gameState.nextPieces.length < 5) {
                gameState.nextPieces.push(getNextPiece());
            }
        }
        
        function spawnPiece() {
            const pieceType = gameState.nextPieces.shift();
            fillNextQueue();
            
            const piece = PIECES[pieceType];
            gameState.currentPiece = pieceType;
            gameState.currentRotation = 0;
            gameState.currentX = Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2);
            gameState.currentY = 0;
            
            gameState.stats.totalPieces++;
            gameState.stats.piecesPerType[pieceType]++;
            
            // Check for game over
            if (!isValidPosition(gameState.currentX, gameState.currentY, piece.shape)) {
                gameOver();
                return false;
            }
            
            updateNextDisplay();
            createSpawnEffect();
            
            return true;
        }
        
        // ==================== PIECE MOVEMENT ====================
        function movePiece(dx, dy) {
            const newX = gameState.currentX + dx;
            const newY = gameState.currentY + dy;
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            if (isValidPosition(newX, newY, shape)) {
                gameState.currentX = newX;
                gameState.currentY = newY;
                
                if (dy > 0) {
                    gameState.score += SCORE_SOFT_DROP;
                    updateScore();
                }
                
                // Reset lock timer on successful movement
                if (dy === 0 && isOnGround()) {
                    gameState.lockTimer = 0;
                }
                
                return true;
            }
            
            return false;
        }
        
        function rotatePiece(direction) {
            const piece = PIECES[gameState.currentPiece];
            const oldRotation = gameState.currentRotation;
            const newRotation = (oldRotation + direction + 4) % 4;
            
            const oldShape = getRotatedShape(piece.shape, oldRotation);
            const newShape = getRotatedShape(piece.shape, newRotation);
            
            // Try basic rotation
            if (isValidPosition(gameState.currentX, gameState.currentY, newShape)) {
                gameState.currentRotation = newRotation;
                checkTSpin();
                createRotateEffect();
                return true;
            }
            
            // Try wall kicks
            const kickData = piece.name === 'I' ? WALL_KICKS.I : WALL_KICKS.normal;
            const kickKey = `${oldRotation}->${newRotation}`;
            const kicks = kickData[kickKey] || [];
            
            for (const [kickX, kickY] of kicks) {
                if (isValidPosition(gameState.currentX + kickX, gameState.currentY + kickY, newShape)) {
                    gameState.currentX += kickX;
                    gameState.currentY += kickY;
                    gameState.currentRotation = newRotation;
                    checkTSpin();
                    createRotateEffect();
                    return true;
                }
            }
            
            return false;
        }
        
        function getRotatedShape(shape, rotation) {
            let result = shape;
            for (let i = 0; i < rotation; i++) {
                result = rotateMatrix(result);
            }
            return result;
        }
        
        function rotateMatrix(matrix) {
            const n = matrix.length;
            const rotated = Array(n).fill(null).map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    rotated[j][n - 1 - i] = matrix[i][j];
                }
            }
            
            return rotated;
        }
        
        function hardDrop() {
            let dropDistance = 0;
            while (movePiece(0, 1)) {
                dropDistance++;
            }
            
            gameState.score += dropDistance * SCORE_HARD_DROP;
            updateScore();
            lockPiece();
            createHardDropEffect();
        }
        
        function holdPiece() {
            if (!gameState.canHold) return;
            
            const temp = gameState.currentPiece;
            
            if (gameState.holdPiece === null) {
                gameState.holdPiece = temp;
                spawnPiece();
            } else {
                gameState.currentPiece = gameState.holdPiece;
                gameState.holdPiece = temp;
                
                const piece = PIECES[gameState.currentPiece];
                gameState.currentRotation = 0;
                gameState.currentX = Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2);
                gameState.currentY = 0;
            }
            
            gameState.canHold = false;
            updateHoldDisplay();
            createHoldEffect();
        }
        
        // ==================== COLLISION DETECTION ====================
        function isValidPosition(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardX = x + col;
                        const boardY = y + row;
                        
                        if (boardX < 0 || boardX >= BOARD_WIDTH || 
                            boardY >= BOARD_HEIGHT ||
                            (boardY >= 0 && gameState.board[boardY][boardX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        function isOnGround() {
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            return !isValidPosition(gameState.currentX, gameState.currentY + 1, shape);
        }
        
        // ==================== PIECE LOCKING ====================
        function lockPiece() {
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            // Add piece to board
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const boardY = gameState.currentY + row;
                        const boardX = gameState.currentX + col;
                        
                        if (boardY >= 0) {
                            gameState.board[boardY][boardX] = gameState.currentPiece + 1;
                        }
                    }
                }
            }
            
            // Reset hold ability
            gameState.canHold = true;
            
            // Check for line clears
            const clearedLines = checkLineClears();
            
            // Handle scoring and effects
            if (clearedLines.length > 0) {
                handleLineClears(clearedLines);
            } else {
                // Reset combo
                gameState.combo = 0;
                gameState.lastClearWasSpecial = false;
            }
            
            // Spawn next piece
            spawnPiece();
        }
        
        // ==================== LINE CLEARING ====================
        function checkLineClears() {
            const linesToClear = [];
            
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (gameState.board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }
            
            return linesToClear;
        }
        
        function handleLineClears(lines) {
            gameState.linesClearingAnimation = true;
            
            // Calculate score
            let baseScore = 0;
            let isTSpin = checkLastMoveWasTSpin();
            
            switch (lines.length) {
                case 1:
                    baseScore = isTSpin ? SCORE_TSPIN_SINGLE : SCORE_SINGLE;
                    break;
                case 2:
                    baseScore = isTSpin ? SCORE_TSPIN_DOUBLE : SCORE_DOUBLE;
                    break;
                case 3:
                    baseScore = isTSpin ? SCORE_TSPIN_TRIPLE : SCORE_TRIPLE;
                    break;
                case 4:
                    baseScore = SCORE_TETRIS;
                    gameState.stats.tetrisCount++;
                    if (gameState.stats.tetrisCount === 1) {
                        unlockAchievement('firstTetris');
                    }
                    break;
            }
            
            // Apply combo multiplier
            gameState.combo++;
            const comboBonus = gameState.combo * COMBO_MULTIPLIER;
            
            // Apply back-to-back bonus
            let b2bMultiplier = 1;
            if ((lines.length === 4 || isTSpin) && gameState.lastClearWasSpecial) {
                b2bMultiplier = B2B_MULTIPLIER;
                gameState.stats.b2b++;
            }
            
            gameState.lastClearWasSpecial = (lines.length === 4 || isTSpin);
            
            // Calculate final score
            const totalScore = Math.floor((baseScore + comboBonus) * b2bMultiplier * gameState.level);
            gameState.score += totalScore;
            
            // Update lines
            gameState.lines += lines.length;
            
            // Add time bonus
            let timeBonus = TIME_BONUSES[lines.length] || 0;
            if (isTSpin) timeBonus += TIME_BONUSES.tspin;
            if (gameState.combo > 1) timeBonus += TIME_BONUSES.combo * Math.min(gameState.combo - 1, 5);
            
            gameState.timeLeft += timeBonus;
            
            // Check for level up
            const newLevel = Math.floor(gameState.lines / LINES_PER_LEVEL) + 1;
            if (newLevel > gameState.level && newLevel <= MAX_LEVEL) {
                gameState.level = newLevel;
                gameState.timeLeft += TIME_BONUSES.levelup;
                createLevelUpEffect();
                
                if (gameState.level === 10) {
                    unlockAchievement('speedDemon');
                }
            }
            
            // Update stats
            if (gameState.combo > gameState.stats.maxCombo) {
                gameState.stats.maxCombo = gameState.combo;
                if (gameState.combo >= 10) {
                    unlockAchievement('comboKing');
                }
            }
            
            // Update displays
            updateScore();
            updateStats();
            
            // Create effects
            createLineClearEffects(lines);
            showCombo();
            showTimeBonus(timeBonus, lines.length, isTSpin);
            
            // Clear lines after animation
            setTimeout(() => {
                clearLines(lines);
                gameState.linesClearingAnimation = false;
                
                // Check for perfect clear
                if (isBoardEmpty()) {
                    handlePerfectClear();
                }
            }, LINE_CLEAR_DELAY);
        }
        
        function clearLines(lines) {
            // Remove cleared lines
            lines.sort((a, b) => b - a);
            for (const line of lines) {
                gameState.board.splice(line, 1);
                gameState.board.unshift(Array(BOARD_WIDTH).fill(0));
            }
        }
        
        function isBoardEmpty() {
            return gameState.board.every(row => row.every(cell => cell === 0));
        }
        
        function handlePerfectClear() {
            gameState.score += 1000 * gameState.level;
            gameState.timeLeft += 30;
            updateScore();
            unlockAchievement('perfectClear');
            createPerfectClearEffect();
        }
        
        // ==================== T-SPIN DETECTION ====================
        function checkTSpin() {
            if (PIECES[gameState.currentPiece].name !== 'T') return false;
            
            const corners = [
                [gameState.currentY, gameState.currentX],
                [gameState.currentY, gameState.currentX + 2],
                [gameState.currentY + 2, gameState.currentX],
                [gameState.currentY + 2, gameState.currentX + 2]
            ];
            
            let filledCorners = 0;
            for (const [y, x] of corners) {
                if (y < 0 || y >= BOARD_HEIGHT || x < 0 || x >= BOARD_WIDTH || gameState.board[y][x]) {
                    filledCorners++;
                }
            }
            
            return filledCorners >= 3;
        }
        
        function checkLastMoveWasTSpin() {
            const isTSpin = checkTSpin();
            if (isTSpin) {
                gameState.stats.tspins++;
                if (gameState.stats.tspins === 5) {
                    unlockAchievement('tspinMaster');
                }
            }
            return isTSpin;
        }
        
        // ==================== GAME UPDATE LOOP ====================
        let lastTime = 0;
        let animationId = null;
        
        function gameLoop(currentTime) {
            if (!gameState.gameActive) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (!gameState.gamePaused) {
                update(deltaTime);
            }
            
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        function update(deltaTime) {
            // Update timer
            gameState.timeLeft -= deltaTime / 1000;
            if (gameState.timeLeft <= 0) {
                gameOver();
                return;
            }
            updateTimer();
            
            // Update DAS
            updateDAS(deltaTime);
            
            // Skip piece movement during line clear animation
            if (gameState.linesClearingAnimation) return;
            
            // Update drop timer
            const dropSpeed = gameState.softDropping ? SOFT_DROP_SPEED : getDropSpeed();
            gameState.dropTimer += deltaTime;
            
            if (gameState.dropTimer >= dropSpeed) {
                gameState.dropTimer = 0;
                
                if (!movePiece(0, 1)) {
                    // Piece hit ground, start lock timer
                    gameState.lockTimer += deltaTime;
                    
                    if (gameState.lockTimer >= LOCK_DELAY) {
                        lockPiece();
                        gameState.lockTimer = 0;
                    }
                } else {
                    // Reset lock timer if piece moved down successfully
                    gameState.lockTimer = 0;
                }
            }
            
            // Update lock timer for pieces on ground
            if (isOnGround() && gameState.lockTimer > 0) {
                gameState.lockTimer += deltaTime;
                if (gameState.lockTimer >= LOCK_DELAY) {
                    lockPiece();
                    gameState.lockTimer = 0;
                }
            }
            
            // Check achievements
            checkTimeAchievements();
        }
        
        function getDropSpeed() {
            const levelIndex = Math.min(gameState.level - 1, SPEED_CURVE.length - 1);
            return SPEED_CURVE[levelIndex];
        }
        
        // ==================== DRAWING ====================
        function draw() {
            // Clear main canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid();
            
            // Draw board
            drawBoard();
            
            // Draw ghost piece
            drawGhostPiece();
            
            // Draw current piece
            drawCurrentPiece();
            
            // Draw lock timer indicator
            if (isOnGround() && gameState.lockTimer > 0) {
                drawLockIndicator();
            }
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 180, 166, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= VISIBLE_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
        }
        
        function drawBoard() {
            for (let y = 2; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (gameState.board[y][x]) {
                        const pieceType = gameState.board[y][x] - 1;
                        const piece = PIECES[pieceType];
                        drawBlock(x * BLOCK_SIZE, (y - 2) * BLOCK_SIZE, piece.color, piece.glow);
                    }
                }
            }
        }
        
        function drawCurrentPiece() {
            if (gameState.currentPiece === null) return;
            
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const x = (gameState.currentX + col) * BLOCK_SIZE;
                        const y = (gameState.currentY + row - 2) * BLOCK_SIZE;
                        
                        if (gameState.currentY + row >= 2) {
                            drawBlock(x, y, piece.color, piece.glow, true);
                        }
                    }
                }
            }
        }
        
        function drawGhostPiece() {
            if (gameState.currentPiece === null) return;
            
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            // Find ghost position
            let ghostY = gameState.currentY;
            while (isValidPosition(gameState.currentX, ghostY + 1, shape)) {
                ghostY++;
            }
            
            // Draw ghost
            ctx.save();
            ctx.globalAlpha = 0.2;
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const x = (gameState.currentX + col) * BLOCK_SIZE;
                        const y = (ghostY + row - 2) * BLOCK_SIZE;
                        
                        if (ghostY + row >= 2) {
                            drawBlock(x, y, piece.color, piece.glow);
                        }
                    }
                }
            }
            
            ctx.restore();
        }
        
        function drawBlock(x, y, color, glow, active = false) {
            const padding = 1;
            const bx = x + padding;
            const by = y + padding;
            const size = BLOCK_SIZE - padding * 2;
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(bx + 2, by + 2, size, size);
            
            // Glow effect
            if (active) {
                ctx.shadowColor = glow;
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            // Main block with gradient
            const gradient = ctx.createLinearGradient(bx, by, bx + size, by + size);
            gradient.addColorStop(0, lightenColor(color, 20));
            gradient.addColorStop(0.5, color);
            gradient.addColorStop(1, darkenColor(color, 20));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(bx, by, size, size);
            
            // Border
            ctx.strokeStyle = lightenColor(color, 30);
            ctx.lineWidth = 2;
            ctx.strokeRect(bx, by, size, size);
            
            // Inner glow
            const innerGradient = ctx.createRadialGradient(
                bx + size/2, by + size/2, 0,
                bx + size/2, by + size/2, size/2
            );
            innerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            innerGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.1)');
            innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = innerGradient;
            ctx.fillRect(bx, by, size, size);
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fillRect(bx + 2, by + 2, size - 4, 2);
            ctx.fillRect(bx + 2, by + 2, 2, size - 4);
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }
        
        function drawLockIndicator() {
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            ctx.save();
            ctx.globalAlpha = gameState.lockTimer / LOCK_DELAY;
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const x = (gameState.currentX + col) * BLOCK_SIZE;
                        const y = (gameState.currentY + row - 2) * BLOCK_SIZE;
                        
                        if (gameState.currentY + row >= 2) {
                            ctx.strokeRect(x + 2, y + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
                        }
                    }
                }
            }
            
            ctx.restore();
        }
        
        // ==================== UI UPDATES ====================
        function updateScore() {
            const scoreDisplay = document.getElementById('scoreDisplay');
            scoreDisplay.textContent = gameState.score.toLocaleString();
            scoreDisplay.classList.add('pulse');
            setTimeout(() => scoreDisplay.classList.remove('pulse'), 300);
            
            // Update level and lines
            document.getElementById('levelDisplay').textContent = gameState.level;
            document.getElementById('linesDisplay').textContent = gameState.lines;
            document.getElementById('levelProgressValue').textContent = gameState.level;
            
            // Update progress bar
            const progress = (gameState.lines % LINES_PER_LEVEL) / LINES_PER_LEVEL * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }
        
        function updateTimer() {
            const timerDisplay = document.getElementById('timerDisplay');
            const timeValue = document.getElementById('timeValue');
            
            timeValue.textContent = Math.ceil(gameState.timeLeft);
            
            if (gameState.timeLeft < 10) {
                timerDisplay.classList.add('critical');
            } else {
                timerDisplay.classList.remove('critical');
            }
        }
        
        function updateStats() {
            document.getElementById('tspinStat').textContent = gameState.stats.tspins;
            document.getElementById('comboStat').textContent = gameState.stats.maxCombo;
            document.getElementById('b2bStat').textContent = gameState.stats.b2b || 0;
            document.getElementById('tetrisStat').textContent = gameState.stats.tetrisCount;
        }
        
        function updateNextDisplay() {
            for (let i = 0; i < 3; i++) {
                const ctx = nextContexts[i];
                const canvas = nextCanvases[i];
                
                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (i < gameState.nextPieces.length) {
                    const pieceType = gameState.nextPieces[i];
                    const piece = PIECES[pieceType];
                    const blockSize = 20;
                    
                    // Center piece
                    const offsetX = (canvas.width - piece.shape[0].length * blockSize) / 2;
                    const offsetY = (canvas.height - piece.shape.length * blockSize) / 2;
                    
                    // Draw piece
                    for (let row = 0; row < piece.shape.length; row++) {
                        for (let col = 0; col < piece.shape[row].length; col++) {
                            if (piece.shape[row][col]) {
                                drawSmallBlock(
                                    ctx,
                                    offsetX + col * blockSize,
                                    offsetY + row * blockSize,
                                    blockSize,
                                    piece.color
                                );
                            }
                        }
                    }
                }
            }
        }
        
        function updateHoldDisplay() {
            // Clear canvas
            holdCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
            
            if (gameState.holdPiece !== null) {
                const piece = PIECES[gameState.holdPiece];
                const blockSize = 18;
                
                // Center piece
                const offsetX = (holdCanvas.width - piece.shape[0].length * blockSize) / 2;
                const offsetY = (holdCanvas.height - piece.shape.length * blockSize) / 2;
                
                // Set opacity based on hold availability
                holdCtx.globalAlpha = gameState.canHold ? 1 : 0.3;
                
                // Draw piece
                for (let row = 0; row < piece.shape.length; row++) {
                    for (let col = 0; col < piece.shape[row].length; col++) {
                        if (piece.shape[row][col]) {
                            drawSmallBlock(
                                holdCtx,
                                offsetX + col * blockSize,
                                offsetY + row * blockSize,
                                blockSize,
                                piece.color
                            );
                        }
                    }
                }
                
                holdCtx.globalAlpha = 1;
            }
        }
        
        function drawSmallBlock(ctx, x, y, size, color) {
            const padding = 1;
            const bx = x + padding;
            const by = y + padding;
            const blockSize = size - padding * 2;
            
            // Main block
            ctx.fillStyle = color;
            ctx.fillRect(bx, by, blockSize, blockSize);
            
            // Border
            ctx.strokeStyle = lightenColor(color, 30);
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, blockSize, blockSize);
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(bx + 1, by + 1, blockSize - 2, 2);
            ctx.fillRect(bx + 1, by + 1, 2, blockSize - 2);
        }
        
        // ==================== VISUAL EFFECTS ====================
        function createSpawnEffect() {
            const piece = PIECES[gameState.currentPiece];
            const centerX = (gameState.currentX + piece.shape[0].length / 2) * BLOCK_SIZE;
            const centerY = (gameState.currentY + piece.shape.length / 2) * BLOCK_SIZE;
            
            // Create particles
            for (let i = 0; i < 10; i++) {
                createParticle(centerX, centerY, {
                    type: 'spark',
                    color: piece.color,
                    velocity: {
                        x: (Math.random() - 0.5) * 200,
                        y: (Math.random() - 0.5) * 200
                    },
                    lifetime: 1000
                });
            }
        }
        
        function createRotateEffect() {
            const piece = PIECES[gameState.currentPiece];
            const centerX = (gameState.currentX + piece.shape[0].length / 2) * BLOCK_SIZE;
            const centerY = (gameState.currentY + piece.shape.length / 2 - 2) * BLOCK_SIZE;
            
            // Create circular particles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                createParticle(centerX, centerY, {
                    type: 'spark',
                    color: piece.color,
                    velocity: {
                        x: Math.cos(angle) * 150,
                        y: Math.sin(angle) * 150
                    },
                    lifetime: 800
                });
            }
        }
        
        function createHardDropEffect() {
            const piece = PIECES[gameState.currentPiece];
            const shape = getRotatedShape(piece.shape, gameState.currentRotation);
            
            // Create impact wave
            const wave = document.createElement('div');
            wave.className = 'powerup-wave';
            wave.style.border = `3px solid ${piece.color}`;
            document.getElementById('effectsOverlay').appendChild(wave);
            
            setTimeout(() => wave.remove(), 1000);
            
            // Screen shake
            document.getElementById('gameContainer').classList.add('screen-shake');
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('screen-shake');
            }, 500);
        }
        
        function createHoldEffect() {
            const holdBox = document.querySelector('.hold-box');
            holdBox.style.animation = 'none';
            setTimeout(() => {
                holdBox.style.animation = 'pulse 0.5s ease';
            }, 10);
        }
        
        function createLineClearEffects(lines) {
            const canvasRect = canvas.getBoundingClientRect();
            const overlayRect = document.getElementById('effectsOverlay').getBoundingClientRect();
            
            lines.forEach(line => {
                // Create line flash
                const flash = document.createElement('div');
                flash.className = 'line-clear-effect';
                flash.style.top = ((line - 2) * BLOCK_SIZE) + 'px';
                flash.innerHTML = '<div class="line-flash"></div>';
                document.querySelector('.canvas-area').appendChild(flash);
                
                setTimeout(() => flash.remove(), 600);
                
                // Create particles along the line
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    const pieceType = gameState.board[line][x] - 1;
                    if (pieceType >= 0) {
                        const piece = PIECES[pieceType];
                        const particleX = x * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const particleY = (line - 2) * BLOCK_SIZE + BLOCK_SIZE / 2;
                        
                        // Multiple particles per block
                        for (let i = 0; i < 5; i++) {
                            createParticle(
                                particleX + (Math.random() - 0.5) * BLOCK_SIZE,
                                particleY + (Math.random() - 0.5) * BLOCK_SIZE,
                                {
                                    type: Math.random() > 0.5 ? 'spark' : 'star',
                                    color: piece.color,
                                    velocity: {
                                        x: (Math.random() - 0.5) * 300,
                                        y: -Math.random() * 200 - 100
                                    },
                                    gravity: 500,
                                    lifetime: 1500
                                }
                            );
                        }
                    }
                }
            });
            
            // Screen flash for Tetris
            if (lines.length === 4) {
                const flash = document.getElementById('screenFlash');
                flash.classList.add('active');
                setTimeout(() => flash.classList.remove('active'), 300);
            }
        }
        
        function createLevelUpEffect() {
            // Create expanding rings
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const ring = document.createElement('div');
                    ring.className = 'powerup-wave';
                    ring.style.border = '3px solid var(--cyan-neon)';
                    document.getElementById('effectsOverlay').appendChild(ring);
                    setTimeout(() => ring.remove(), 1000);
                }, i * 200);
            }
            
            // Flash level display
            const levelDisplay = document.getElementById('levelDisplay');
            levelDisplay.style.animation = 'none';
            setTimeout(() => {
                levelDisplay.style.animation = 'pulse 1s ease';
            }, 10);
        }
        
        function createPerfectClearEffect() {
            // Create multiple waves
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const wave = document.createElement('div');
                    wave.className = 'powerup-wave';
                    wave.style.border = '3px solid var(--yellow-neon)';
                    document.getElementById('effectsOverlay').appendChild(wave);
                    setTimeout(() => wave.remove(), 1000);
                }, i * 100);
            }
            
            // Create star burst
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                createParticle(centerX, centerY, {
                    type: 'star',
                    color: '#ffeb3b',
                    velocity: {
                        x: Math.cos(angle) * 500,
                        y: Math.sin(angle) * 500
                    },
                    lifetime: 2000
                });
            }
        }
        
        function createParticle(x, y, options) {
            const particle = document.createElement('div');
            particle.className = `particle particle-${options.type}`;
            particle.style.color = options.color;
            
            const canvasRect = document.querySelector('.canvas-area').getBoundingClientRect();
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            
            document.querySelector('.canvas-area').appendChild(particle);
            
            let posX = 0;
            let posY = 0;
            let velocityX = options.velocity.x;
            let velocityY = options.velocity.y;
            let opacity = 1;
            let rotation = 0;
            const startTime = Date.now();
            
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / options.lifetime;
                
                if (progress >= 1) {
                    particle.remove();
                    return;
                }
                
                // Update position
                posX += velocityX * 0.016;
                posY += velocityY * 0.016;
                
                // Apply gravity if specified
                if (options.gravity) {
                    velocityY += options.gravity * 0.016;
                }
                
                // Update opacity
                opacity = 1 - progress;
                
                // Update rotation for star particles
                if (options.type === 'star') {
                    rotation += 5;
                }
                
                // Apply transforms
                particle.style.transform = `translate(${posX}px, ${posY}px) rotate(${rotation}deg)`;
                particle.style.opacity = opacity;
                
                requestAnimationFrame(animate);
            };
            
            requestAnimationFrame(animate);
        }
        
        // ==================== UI EFFECTS ====================
        function showCombo() {
            if (gameState.combo <= 1) return;
            
            const comboDisplay = document.getElementById('comboDisplay');
            comboDisplay.textContent = `${gameState.combo}x COMBO!`;
            comboDisplay.classList.add('show');
            
            setTimeout(() => {
                comboDisplay.classList.remove('show');
            }, 1500);
        }
        
        function showTimeBonus(bonus, lines, isTSpin) {
            const comboDisplay = document.getElementById('comboDisplay');
            
            let message = `+${bonus}s`;
            if (lines === 4) {
                message += '\nTETRIS!';
            } else if (isTSpin) {
                message += '\nT-SPIN!';
            }
            
            comboDisplay.innerHTML = message;
            comboDisplay.style.color = isTSpin ? '#b366ff' : (lines === 4 ? '#ffeb3b' : '#00e676');
            comboDisplay.classList.add('show');
            
            setTimeout(() => {
                comboDisplay.classList.remove('show');
            }, 1500);
        }
        
        // ==================== ACHIEVEMENTS ====================
        function unlockAchievement(achievementId) {
            if (gameState.unlockedAchievements.has(achievementId)) return;
            
            gameState.unlockedAchievements.add(achievementId);
            const achievement = ACHIEVEMENTS[achievementId];
            
            const popup = document.getElementById('achievementPopup');
            document.getElementById('achievementIcon').textContent = achievement.icon;
            document.getElementById('achievementTitle').textContent = achievement.title;
            document.getElementById('achievementDesc').textContent = achievement.desc;
            
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }
        
        function checkTimeAchievements() {
            const playTime = (Date.now() - gameState.gameStartTime) / 1000;
            
            if (playTime >= 300 && !gameState.unlockedAchievements.has('survivor')) {
                unlockAchievement('survivor');
            }
            
            if (gameState.score >= 10000 && !gameState.unlockedAchievements.has('scoreHunter')) {
                unlockAchievement('scoreHunter');
            }
        }
        
        // ==================== GAME CONTROLS ====================
        function startGame() {
            // Hide welcome screen
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Reset game state
            resetGameState();
            
            // Start game
            gameState.gameActive = true;
            gameState.gameStartTime = Date.now();
            
            // Initialize pieces
            fillNextQueue();
            spawnPiece();
            
            // Update displays
            updateScore();
            updateStats();
            updateNextDisplay();
            updateHoldDisplay();
            
            // Start game loop
            lastTime = performance.now();
            gameLoop(lastTime);
        }
        
        function resetGameState() {
            // Reset board
            createBoard();
            
            // Reset piece state
            gameState.currentPiece = null;
            gameState.currentX = 0;
            gameState.currentY = 0;
            gameState.currentRotation = 0;
            gameState.nextPieces = [];
            gameState.bag = [];
            gameState.holdPiece = null;
            gameState.canHold = true;
            
            // Reset game status
            gameState.gamePaused = false;
            
            // Reset scoring
            gameState.score = 0;
            gameState.level = 1;
            gameState.lines = 0;
            gameState.timeLeft = INITIAL_TIME;
            
            // Reset timers
            gameState.dropTimer = 0;
            gameState.lockTimer = 0;
            gameState.softDropping = false;
            gameState.dasTimer = 0;
            gameState.arrTimer = 0;
            gameState.currentDAS = null;
            
            // Reset combos
            gameState.combo = 0;
            gameState.b2b = false;
            gameState.lastClearWasSpecial = false;
            
            // Reset stats
            gameState.stats = {
                tspins: 0,
                maxCombo: 0,
                tetrisCount: 0,
                totalPieces: 0,
                piecesPerType: [0, 0, 0, 0, 0, 0, 0]
            };
            
            // Keep achievements
            gameState.linesClearingAnimation = false;
        }
        
        function pauseGame() {
            gameState.gamePaused = true;
            document.getElementById('pauseMenu').style.display = 'flex';
        }
        
        function resumeGame() {
            gameState.gamePaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            lastTime = performance.now();
        }
        
        function togglePause() {
            if (gameState.gamePaused) {
                resumeGame();
            } else {
                pauseGame();
            }
        }
        
        function restartGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            startGame();
        }
        
        function quitGame() {
            gameState.gameActive = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            showMainMenu();
        }
        
        function showMainMenu() {
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
        }
        
        function gameOver() {
            gameState.gameActive = false;
            
            // Calculate play time
            const playTime = Math.floor((Date.now() - gameState.gameStartTime) / 1000);
            const minutes = Math.floor(playTime / 60);
            const seconds = playTime % 60;
            
            // Update final stats
            document.getElementById('finalScore').textContent = gameState.score.toLocaleString();
            document.getElementById('finalLevel').textContent = gameState.level;
            document.getElementById('finalLines').textContent = gameState.lines;
            document.getElementById('finalTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            // Check for new high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('tetrisHighScore', gameState.score);
                document.getElementById('newRecord').style.display = 'block';
            } else {
                document.getElementById('newRecord').style.display = 'none';
            }
            
            // Show game over screen
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            // Cancel animation loop
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        // ==================== HELPER FUNCTIONS ====================
        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        // ==================== INITIALIZATION ====================
        init();
    </script>
</body>
</html>
