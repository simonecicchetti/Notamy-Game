<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>NOTAMY TETRIS - Ultimate Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        body {
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        /* Epic background animation */
        .bg-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
        }
        
        .bg-gradient {
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background: radial-gradient(circle at 20% 50%, rgba(0, 217, 255, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 80% 50%, rgba(255, 107, 107, 0.2) 0%, transparent 50%),
                        radial-gradient(circle at 50% 80%, rgba(0, 255, 136, 0.2) 0%, transparent 50%);
            animation: bgRotate 30s linear infinite;
        }
        
        @keyframes bgRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .bg-particles {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        .bg-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00d9ff;
            border-radius: 50%;
            box-shadow: 0 0 10px currentColor;
            animation: particleFloat 20s linear infinite;
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) translateX(100px);
                opacity: 0;
            }
        }
        
        /* Main game area */
        #gameArea {
            position: relative;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid transparent;
            border-image: linear-gradient(45deg, #00d9ff, #00ff88, #ff6b6b, #ffab00) 1;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 100px rgba(0, 217, 255, 0.5),
                        inset 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            gap: 20px;
            align-items: flex-start;
            backdrop-filter: blur(10px);
            z-index: 10;
            animation: gameAreaGlow 4s ease-in-out infinite;
        }
        
        @keyframes gameAreaGlow {
            0%, 100% { 
                box-shadow: 0 0 100px rgba(0, 217, 255, 0.5),
                           inset 0 0 50px rgba(0, 0, 0, 0.5);
            }
            50% { 
                box-shadow: 0 0 150px rgba(0, 255, 136, 0.7),
                           inset 0 0 50px rgba(0, 0, 0, 0.5);
            }
        }
        
        /* Game board */
        #board {
            position: relative;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, rgba(10, 10, 20, 0.9) 100%);
            border: 2px solid rgba(0, 217, 255, 0.3);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0, 217, 255, 0.1);
        }
        
        #gameCanvas {
            display: block;
            position: relative;
            z-index: 2;
        }
        
        /* Canvas overlay effects */
        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 217, 255, 0.05) 100%);
        }
        
        /* Side panel with glass effect */
        #sidePanel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 180px;
        }
        
        /* Timer with epic design */
        #timerContainer {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.2), rgba(255, 82, 82, 0.1));
            border: 3px solid #ff6b6b;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5),
                        inset 0 0 20px rgba(255, 107, 107, 0.2);
        }
        
        #timerBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff5252, #ff6b6b);
            background-size: 200% 100%;
            transform-origin: bottom;
            transition: transform 0.1s linear;
            opacity: 0.3;
            animation: timerGradient 2s linear infinite;
        }
        
        @keyframes timerGradient {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }
        
        #timerDisplay {
            position: relative;
            font-size: 48px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px #ff6b6b,
                         0 0 60px #ff6b6b;
            z-index: 1;
            animation: timerPulse 1s ease-in-out infinite;
        }
        
        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .timer-label {
            font-size: 14px;
            color: #ff6b6b;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
            font-weight: 700;
            text-shadow: 0 0 10px currentColor;
        }
        
        /* Score with neon effect */
        .score-container {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.2), rgba(0, 153, 204, 0.1));
            border: 2px solid #00d9ff;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.5),
                        inset 0 0 20px rgba(0, 217, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .score-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00d9ff, transparent, #00ff88);
            border-radius: 20px;
            opacity: 0;
            z-index: -1;
            animation: scoreGlow 3s ease-in-out infinite;
        }
        
        @keyframes scoreGlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.5; }
        }
        
        .score-label {
            font-size: 14px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            font-weight: 700;
        }
        
        .score-value {
            font-size: 32px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px #00d9ff;
            transition: all 0.3s;
        }
        
        /* Next piece preview */
        .next-container {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 204, 106, 0.1));
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5),
                        inset 0 0 20px rgba(0, 255, 136, 0.2);
        }
        
        .next-label {
            font-size: 14px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            font-weight: 700;
            text-shadow: 0 0 10px currentColor;
        }
        
        #nextCanvas {
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        
        /* Level & Lines */
        .stat-container {
            background: linear-gradient(135deg, rgba(167, 139, 250, 0.2), rgba(139, 92, 246, 0.1));
            border: 2px solid #a78bfa;
            border-radius: 20px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(167, 139, 250, 0.5),
                        inset 0 0 20px rgba(167, 139, 250, 0.2);
        }
        
        .stat-label {
            font-size: 12px;
            color: #a78bfa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            font-weight: 700;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 15px #a78bfa;
        }
        
        /* Mobile swipe areas */
        .swipe-areas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            z-index: 5;
            pointer-events: none;
        }
        
        .swipe-left, .swipe-right {
            flex: 1;
            height: 100%;
            pointer-events: auto;
        }
        
        /* Time bonus popup */
        .time-bonus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            font-weight: 900;
            color: #00ff88;
            text-shadow: 0 0 50px currentColor,
                         0 0 100px currentColor;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
            text-align: center;
        }
        
        .time-bonus.show {
            animation: timeBonusEpic 1.5s ease-out;
        }
        
        @keyframes timeBonusEpic {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0) rotate(-720deg);
            }
            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.5) rotate(-360deg);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1) rotate(0) translateY(-200px);
            }
        }
        
        /* Epic particle system */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 200;
        }
        
        .particle-glow {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, currentColor 0%, transparent 70%);
            border-radius: 50%;
            filter: blur(2px);
        }
        
        /* Line clear explosion */
        .line-explosion {
            position: absolute;
            width: 100%;
            height: 30px;
            pointer-events: none;
            z-index: 50;
        }
        
        .line-explosion-wave {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                #fff, 
                #00d9ff,
                #fff,
                transparent);
            opacity: 0;
            animation: lineExplosion 0.6s ease-out;
        }
        
        @keyframes lineExplosion {
            0% {
                transform: scaleX(0) scaleY(1);
                opacity: 0;
            }
            50% {
                transform: scaleX(1) scaleY(3);
                opacity: 1;
            }
            100% {
                transform: scaleX(1.2) scaleY(0);
                opacity: 0;
            }
        }
        
        /* Game over with style */
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0, 0, 0, 0.95), #000);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
        }
        
        .game-over-content {
            text-align: center;
            padding: 20px;
            max-width: 450px;
            animation: gameOverSlide 0.5s ease-out;
        }
        
        @keyframes gameOverSlide {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .game-over-title {
            font-size: 72px;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #ffab00, #ff6b6b);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 30px;
            animation: gameOverGradient 2s linear infinite;
            text-transform: uppercase;
            letter-spacing: 5px;
        }
        
        @keyframes gameOverGradient {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }
        
        .final-stats {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 217, 255, 0.3);
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            font-size: 20px;
        }
        
        .stat-row .label {
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-row .value {
            color: #fff;
            font-weight: 900;
            text-shadow: 0 0 10px currentColor;
        }
        
        /* Epic buttons */
        .epic-button {
            background: linear-gradient(135deg, #00d9ff, #00ff88);
            border: none;
            color: #000;
            padding: 20px 60px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin: 10px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            box-shadow: 0 10px 40px rgba(0, 217, 255, 0.5);
        }
        
        .epic-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }
        
        .epic-button:hover::before {
            left: 100%;
        }
        
        .epic-button:active {
            transform: scale(0.95);
        }
        
        /* Welcome screen */
        .welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }
        
        .welcome-content {
            text-align: center;
            animation: welcomeFade 1s ease-out;
        }
        
        @keyframes welcomeFade {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .welcome-title {
            font-size: 100px;
            font-weight: 900;
            background: linear-gradient(45deg, 
                #00d9ff, #00ff88, #ff6b6b, #ffab00, #a78bfa, #00d9ff);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: epicGradient 5s ease-in-out infinite;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 0 0 100px rgba(0, 217, 255, 0.5);
        }
        
        @keyframes epicGradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .welcome-subtitle {
            font-size: 32px;
            color: #00ff88;
            margin-bottom: 50px;
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 0 0 30px currentColor;
            animation: subtitleGlow 2s ease-in-out infinite;
        }
        
        @keyframes subtitleGlow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .welcome-description {
            font-size: 20px;
            color: #fff;
            margin-bottom: 50px;
            text-align: center;
            max-width: 500px;
            line-height: 1.6;
            opacity: 0.9;
        }
        
        /* Epic screen shake */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5px, -5px); }
            20% { transform: translate(5px, -5px); }
            30% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, 5px); }
            50% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, -2px); }
            70% { transform: translate(-2px, 2px); }
            80% { transform: translate(2px, 2px); }
            90% { transform: translate(0, 0); }
        }
        
        .shake {
            animation: screenShake 0.5s ease-in-out;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            #gameArea {
                flex-direction: column;
                padding: 15px;
                gap: 15px;
            }
            
            #sidePanel {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                min-width: auto;
                gap: 10px;
                width: 100%;
            }
            
            #sidePanel > * {
                flex: 1;
                min-width: 120px;
            }
            
            .welcome-title {
                font-size: 60px;
                letter-spacing: 5px;
            }
            
            .welcome-subtitle {
                font-size: 24px;
                letter-spacing: 3px;
            }
            
            #timerDisplay {
                font-size: 36px;
            }
            
            .score-value {
                font-size: 24px;
            }
        }
        
        /* Power mode effect */
        .power-mode {
            animation: powerMode 0.5s ease-in-out;
        }
        
        @keyframes powerMode {
            0%, 100% { filter: brightness(1) contrast(1); }
            50% { filter: brightness(1.5) contrast(1.2); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Epic background -->
        <div class="bg-container">
            <div class="bg-gradient"></div>
            <div class="bg-particles" id="bgParticles"></div>
        </div>
        
        <!-- Time bonus popup -->
        <div class="time-bonus" id="timeBonusPopup"></div>
        
        <!-- Main game area -->
        <div id="gameArea">
            <!-- Game board -->
            <div id="board">
                <canvas id="gameCanvas"></canvas>
                <div class="canvas-overlay"></div>
                <!-- Touch areas for mobile -->
                <div class="swipe-areas">
                    <div class="swipe-left" id="swipeLeft"></div>
                    <div class="swipe-right" id="swipeRight"></div>
                </div>
            </div>
            
            <!-- Side panel -->
            <div id="sidePanel">
                <!-- Timer -->
                <div id="timerContainer">
                    <div id="timerBar"></div>
                    <div class="timer-label">TEMPO</div>
                    <div id="timerDisplay">30</div>
                </div>
                
                <!-- Score -->
                <div class="score-container">
                    <div class="score-label">PUNTI</div>
                    <div class="score-value" id="scoreDisplay">0</div>
                </div>
                
                <!-- Next piece -->
                <div class="next-container">
                    <div class="next-label">PROSSIMO</div>
                    <canvas id="nextCanvas" width="100" height="100"></canvas>
                </div>
                
                <!-- Stats -->
                <div class="stat-container">
                    <div class="stat-label">LIVELLO</div>
                    <div class="stat-value" id="levelDisplay">1</div>
                </div>
                
                <div class="stat-container">
                    <div class="stat-label">LINEE</div>
                    <div class="stat-value" id="linesDisplay">0</div>
                </div>
            </div>
        </div>
        
        <!-- Welcome screen -->
        <div class="welcome-screen" id="welcomeScreen">
            <div class="welcome-content">
                <h1 class="welcome-title">TETRIS</h1>
                <h2 class="welcome-subtitle">TIME ATTACK</h2>
                <p class="welcome-description">
                    Completa le linee per guadagnare tempo!<br>
                    <strong>Tocca lo schermo per ruotare</strong><br>
                    Swipe per muovere i blocchi
                </p>
                <button class="epic-button" onclick="startGame()">INIZIA</button>
            </div>
        </div>
        
        <!-- Game over overlay -->
        <div class="game-over-overlay" id="gameOverOverlay">
            <div class="game-over-content">
                <h1 class="game-over-title">GAME OVER</h1>
                
                <div class="final-stats">
                    <div class="stat-row">
                        <span class="label">Punteggio</span>
                        <span class="value" id="finalScore">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Linee</span>
                        <span class="value" id="finalLines">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Livello</span>
                        <span class="value" id="finalLevel">1</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">Record</span>
                        <span class="value" id="bestScore">0</span>
                    </div>
                </div>
                
                <button class="epic-button" onclick="restartGame()">RIGIOCA</button>
                <button class="epic-button" onclick="showWelcome()">MENU</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 30;
        const INITIAL_TIME = 30;
        const DROP_SPEED = 800;
        const FAST_DROP_SPEED = 50;
        
        // Notamy Style Tetromino pieces
        const PIECES = [
            // I - Cyan Neon
            {
                shape: [[1,1,1,1]],
                color: '#00d9ff',
                glow: '#00d9ff',
                gradient: ['#00d9ff', '#0099cc', '#006699']
            },
            // O - Golden Orange
            {
                shape: [[1,1],[1,1]],
                color: '#ffab00',
                glow: '#ffab00',
                gradient: ['#ffab00', '#ff8800', '#cc6600']
            },
            // T - Cosmic Purple
            {
                shape: [[0,1,0],[1,1,1]],
                color: '#a78bfa',
                glow: '#a78bfa',
                gradient: ['#a78bfa', '#8b5cf6', '#6b3cf6']
            },
            // S - Neon Green
            {
                shape: [[0,1,1],[1,1,0]],
                color: '#00ff88',
                glow: '#00ff88',
                gradient: ['#00ff88', '#00cc6a', '#009950']
            },
            // Z - Hot Pink
            {
                shape: [[1,1,0],[0,1,1]],
                color: '#ff6b6b',
                glow: '#ff6b6b',
                gradient: ['#ff6b6b', '#ff4444', '#cc2222']
            },
            // J - Deep Blue
            {
                shape: [[1,0,0],[1,1,1]],
                color: '#3f51b5',
                glow: '#3f51b5',
                gradient: ['#3f51b5', '#303f9f', '#1a237e']
            },
            // L - Electric Red
            {
                shape: [[0,0,1],[1,1,1]],
                color: '#ff5252',
                glow: '#ff5252',
                gradient: ['#ff5252', '#ff1744', '#d50000']
            }
        ];
        
        // Time bonuses
        const TIME_BONUSES = {
            1: 3,
            2: 8,
            3: 15,
            4: 25
        };
        
        // Game state
        let board = [];
        let currentPiece = null;
        let nextPiece = null;
        let score = 0;
        let lines = 0;
        let level = 1;
        let timeLeft = INITIAL_TIME;
        let gameActive = false;
        let dropTimer = 0;
        let currentDropSpeed = DROP_SPEED;
        let bestScore = 0;
        let lastTime = 0;
        let keys = {};
        let touchStartX = null;
        let touchStartY = null;
        let lastTouchTime = 0;
        
        // Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        
        canvas.width = BOARD_WIDTH * BLOCK_SIZE;
        canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
        
        // Initialize
        function init() {
            createBackgroundParticles();
            loadBestScore();
            createBoard();
            setupControls();
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('autostart') === 'true') {
                startGame();
            }
        }
        
        // Create background particles
        function createBackgroundParticles() {
            const container = document.getElementById('bgParticles');
            const colors = ['#00d9ff', '#00ff88', '#ff6b6b', '#ffab00', '#a78bfa'];
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'bg-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                container.appendChild(particle);
            }
        }
        
        // Create board
        function createBoard() {
            board = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0));
        }
        
        // Load best score
        function loadBestScore() {
            bestScore = parseInt(localStorage.getItem('notamyTetrisBest') || '0');
        }
        
        // Save best score
        function saveBestScore() {
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('notamyTetrisBest', bestScore);
            }
        }
        
        // Setup controls
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                
                if (!gameActive) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                    case 'ArrowDown':
                        currentDropSpeed = FAST_DROP_SPEED;
                        break;
                    case ' ':
                        hardDrop();
                        break;
                }
                
                e.preventDefault();
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key] = false;
                
                if (e.key === 'ArrowDown') {
                    currentDropSpeed = DROP_SPEED - (level - 1) * 50;
                }
            });
            
            // Touch on canvas for rotation
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) {
                    const currentTime = Date.now();
                    if (currentTime - lastTouchTime < 300) {
                        // Double tap for hard drop
                        hardDrop();
                    } else {
                        // Single tap for rotation
                        rotatePiece();
                        createRotateEffect();
                    }
                    lastTouchTime = currentTime;
                }
            });
            
            // Swipe areas
            let swipeStartX = 0;
            let swipeTimer = null;
            
            document.getElementById('swipeLeft').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) {
                    movePiece(-1, 0);
                    swipeTimer = setInterval(() => {
                        if (gameActive) movePiece(-1, 0);
                    }, 100);
                }
            });
            
            document.getElementById('swipeRight').addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) {
                    movePiece(1, 0);
                    swipeTimer = setInterval(() => {
                        if (gameActive) movePiece(1, 0);
                    }, 100);
                }
            });
            
            document.addEventListener('touchend', () => {
                if (swipeTimer) {
                    clearInterval(swipeTimer);
                    swipeTimer = null;
                }
                currentDropSpeed = DROP_SPEED - (level - 1) * 50;
            });
            
            // Swipe down for fast drop
            let touchY = 0;
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                if (touchY && touch.clientY - touchY > 30) {
                    currentDropSpeed = FAST_DROP_SPEED;
                }
            });
            
            canvas.addEventListener('touchstart', (e) => {
                touchY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchend', () => {
                touchY = 0;
                currentDropSpeed = DROP_SPEED - (level - 1) * 50;
            });
        }
        
        // Create piece
        function createPiece(type) {
            const piece = PIECES[type];
            return {
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0,
                shape: piece.shape,
                color: piece.color,
                glow: piece.glow,
                gradient: piece.gradient,
                type: type,
                rotation: 0
            };
        }
        
        // Get random piece
        function getRandomPiece() {
            return Math.floor(Math.random() * PIECES.length);
        }
        
        // Check collision
        function isValidPosition(piece, offsetX = 0, offsetY = 0) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        if (newX < 0 || newX >= BOARD_WIDTH || 
                            newY >= BOARD_HEIGHT ||
                            (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        // Move piece
        function movePiece(dx, dy) {
            if (isValidPosition(currentPiece, dx, dy)) {
                currentPiece.x += dx;
                currentPiece.y += dy;
                createMoveEffect(dx);
                return true;
            }
            return false;
        }
        
        // Rotate piece
        function rotatePiece() {
            const rotated = currentPiece.shape[0].map((_, i) =>
                currentPiece.shape.map(row => row[i]).reverse()
            );
            
            const oldShape = currentPiece.shape;
            currentPiece.shape = rotated;
            currentPiece.rotation = (currentPiece.rotation + 90) % 360;
            
            if (!isValidPosition(currentPiece)) {
                // Try wall kicks
                const kicks = [-1, 1, -2, 2];
                let kicked = false;
                
                for (let kick of kicks) {
                    if (isValidPosition(currentPiece, kick, 0)) {
                        currentPiece.x += kick;
                        kicked = true;
                        break;
                    }
                }
                
                if (!kicked) {
                    currentPiece.shape = oldShape;
                    currentPiece.rotation = (currentPiece.rotation - 90) % 360;
                }
            }
        }
        
        // Hard drop
        function hardDrop() {
            let dropDistance = 0;
            while (movePiece(0, 1)) {
                dropDistance++;
                score += 2;
            }
            
            if (dropDistance > 0) {
                createHardDropEffect();
                document.getElementById('gameArea').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('gameArea').classList.remove('shake');
                }, 500);
            }
            
            lockPiece();
        }
        
        // Lock piece
        function lockPiece() {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.type + 1;
                        }
                    }
                }
            }
            
            // Create lock effect
            createLockEffect();
            
            // Check lines
            const clearedLines = checkLines();
            
            // New piece
            currentPiece = createPiece(nextPiece);
            nextPiece = getRandomPiece();
            
            // Game over check
            if (!isValidPosition(currentPiece)) {
                gameOver();
            }
        }
        
        // Check lines
        function checkLines() {
            const linesToClear = [];
            
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }
            
            if (linesToClear.length > 0) {
                clearLines(linesToClear);
                
                lines += linesToClear.length;
                score += [40, 100, 300, 1200][linesToClear.length - 1] * level;
                
                const timeBonus = TIME_BONUSES[linesToClear.length];
                timeLeft += timeBonus;
                showTimeBonus(timeBonus, linesToClear.length);
                
                if (lines >= level * 10) {
                    level++;
                    currentDropSpeed = DROP_SPEED - (level - 1) * 50;
                    createLevelUpEffect();
                }
                
                updateUI();
            }
            
            return linesToClear.length;
        }
        
        // Clear lines
        function clearLines(linesToClear) {
            linesToClear.forEach(y => {
                createLineExplosion(y);
            });
            
            setTimeout(() => {
                linesToClear.forEach(y => {
                    board.splice(y, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                });
            }, 200);
        }
        
        // Effects
        function createRotateEffect() {
            const rect = canvas.getBoundingClientRect();
            const centerX = rect.left + (currentPiece.x + currentPiece.shape[0].length / 2) * BLOCK_SIZE;
            const centerY = rect.top + (currentPiece.y + currentPiece.shape.length / 2) * BLOCK_SIZE;
            
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                createParticle(centerX, centerY, {
                    vx: Math.cos(angle) * 200,
                    vy: Math.sin(angle) * 200,
                    color: currentPiece.glow,
                    size: 4,
                    type: 'rotate'
                });
            }
        }
        
        function createMoveEffect(direction) {
            const rect = canvas.getBoundingClientRect();
            const x = rect.left + (currentPiece.x + (direction > 0 ? currentPiece.shape[0].length : 0)) * BLOCK_SIZE;
            const y = rect.top + currentPiece.y * BLOCK_SIZE;
            
            for (let i = 0; i < 3; i++) {
                createParticle(x, y + i * BLOCK_SIZE * 0.5, {
                    vx: direction * -100,
                    vy: Math.random() * 50 - 25,
                    color: currentPiece.glow,
                    size: 3,
                    type: 'move'
                });
            }
        }
        
        function createHardDropEffect() {
            const rect = canvas.getBoundingClientRect();
            const bottomY = rect.top + (currentPiece.y + currentPiece.shape.length) * BLOCK_SIZE;
            
            for (let x = 0; x < currentPiece.shape[0].length; x++) {
                if (currentPiece.shape[currentPiece.shape.length - 1][x]) {
                    const particleX = rect.left + (currentPiece.x + x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                    
                    for (let i = 0; i < 10; i++) {
                        createParticle(particleX, bottomY, {
                            vx: (Math.random() - 0.5) * 300,
                            vy: -Math.random() * 200 - 100,
                            color: currentPiece.glow,
                            size: 6,
                            type: 'impact'
                        });
                    }
                }
            }
        }
        
        function createLockEffect() {
            const rect = canvas.getBoundingClientRect();
            
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const px = rect.left + (currentPiece.x + x) * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const py = rect.top + (currentPiece.y + y) * BLOCK_SIZE + BLOCK_SIZE / 2;
                        
                        createParticle(px, py, {
                            vx: (Math.random() - 0.5) * 100,
                            vy: (Math.random() - 0.5) * 100,
                            color: currentPiece.glow,
                            size: 2,
                            type: 'lock'
                        });
                    }
                }
            }
        }
        
        function createLineExplosion(y) {
            const explosion = document.createElement('div');
            explosion.className = 'line-explosion';
            explosion.style.top = (y * BLOCK_SIZE) + 'px';
            
            const wave = document.createElement('div');
            wave.className = 'line-explosion-wave';
            explosion.appendChild(wave);
            
            document.getElementById('board').appendChild(explosion);
            
            setTimeout(() => explosion.remove(), 600);
            
            // Particles
            const rect = canvas.getBoundingClientRect();
            for (let x = 0; x < BOARD_WIDTH; x++) {
                const px = rect.left + x * BLOCK_SIZE + BLOCK_SIZE / 2;
                const py = rect.top + y * BLOCK_SIZE + BLOCK_SIZE / 2;
                
                for (let i = 0; i < 5; i++) {
                    const piece = PIECES[board[y][x] - 1];
                    createParticle(px, py, {
                        vx: (Math.random() - 0.5) * 400,
                        vy: -Math.random() * 300 - 100,
                        color: piece ? piece.glow : '#fff',
                        size: 8,
                        type: 'explosion'
                    });
                }
            }
        }
        
        function createLevelUpEffect() {
            document.getElementById('gameContainer').classList.add('power-mode');
            
            const rect = canvas.getBoundingClientRect();
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    createParticle(
                        rect.left + Math.random() * canvas.width,
                        rect.top + canvas.height,
                        {
                            vx: (Math.random() - 0.5) * 200,
                            vy: -Math.random() * 400 - 200,
                            color: PIECES[Math.floor(Math.random() * PIECES.length)].glow,
                            size: 10,
                            type: 'levelup'
                        }
                    );
                }, i * 20);
            }
            
            setTimeout(() => {
                document.getElementById('gameContainer').classList.remove('power-mode');
            }, 1000);
        }
        
        function createParticle(x, y, options) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.width = options.size + 'px';
            particle.style.height = options.size + 'px';
            particle.style.color = options.color;
            
            const glow = document.createElement('div');
            glow.className = 'particle-glow';
            particle.appendChild(glow);
            
            document.getElementById('gameContainer').appendChild(particle);
            
            let opacity = 1;
            let posX = 0;
            let posY = 0;
            let velocityX = options.vx;
            let velocityY = options.vy;
            let size = options.size;
            
            const animate = () => {
                velocityY += 300 * 0.016; // gravity
                velocityX *= 0.98; // friction
                
                posX += velocityX * 0.016;
                posY += velocityY * 0.016;
                
                opacity -= options.type === 'explosion' ? 0.03 : 0.02;
                size *= options.type === 'levelup' ? 1.02 : 0.98;
                
                particle.style.transform = `translate(${posX}px, ${posY}px)`;
                particle.style.opacity = opacity;
                particle.style.width = particle.style.height = size + 'px';
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    particle.remove();
                }
            };
            
            requestAnimationFrame(animate);
        }
        
        // Show time bonus
        function showTimeBonus(bonus, linesCleared) {
            const popup = document.getElementById('timeBonusPopup');
            const messages = ['', 'SINGLE!', 'DOUBLE!!', 'TRIPLE!!!', 'TETRIS!!!!'];
            popup.innerHTML = `
                <div style="font-size: 96px; font-weight: 900;">+${bonus}s</div>
                <div style="font-size: 48px; margin-top: -20px;">${messages[linesCleared]}</div>
            `;
            popup.classList.add('show');
            
            setTimeout(() => {
                popup.classList.remove('show');
            }, 1500);
            
            if (linesCleared >= 3) {
                document.getElementById('gameContainer').classList.add('power-mode');
                setTimeout(() => {
                    document.getElementById('gameContainer').classList.remove('power-mode');
                }, 1000);
            }
        }
        
        // Update game
        function update(currentTime) {
            if (!gameActive) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Timer
            timeLeft -= deltaTime / 1000;
            if (timeLeft <= 0) {
                gameOver();
                return;
            }
            
            updateTimer();
            
            // Drop
            dropTimer += deltaTime;
            if (dropTimer >= currentDropSpeed) {
                dropTimer = 0;
                if (!movePiece(0, 1)) {
                    lockPiece();
                }
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        // Draw game
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Epic grid
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw board
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x]) {
                        const piece = PIECES[board[y][x] - 1];
                        drawNotamyBlock(x * BLOCK_SIZE, y * BLOCK_SIZE, piece, 1);
                    }
                }
            }
            
            // Draw current piece
            if (currentPiece) {
                for (let y = 0; y < currentPiece.shape.length; y++) {
                    for (let x = 0; x < currentPiece.shape[y].length; x++) {
                        if (currentPiece.shape[y][x]) {
                            drawNotamyBlock(
                                (currentPiece.x + x) * BLOCK_SIZE,
                                (currentPiece.y + y) * BLOCK_SIZE,
                                currentPiece,
                                1,
                                true
                            );
                        }
                    }
                }
            }
            
            drawNextPiece();
        }
        
        // Draw Notamy style block
        function drawNotamyBlock(x, y, piece, alpha, isActive = false) {
            const padding = 2;
            const bx = x + padding;
            const by = y + padding;
            const size = BLOCK_SIZE - padding * 2;
            
            ctx.save();
            
            // Glow effect
            if (isActive) {
                ctx.shadowColor = piece.glow;
                ctx.shadowBlur = 20;
            }
            
            // Background glow
            const glowGradient = ctx.createRadialGradient(
                bx + size/2, by + size/2, 0,
                bx + size/2, by + size/2, size
            );
            glowGradient.addColorStop(0, piece.glow + '33');
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(bx - 10, by - 10, size + 20, size + 20);
            
            // Main block with gradient
            const gradient = ctx.createLinearGradient(bx, by, bx + size, by + size);
            piece.gradient.forEach((color, i) => {
                gradient.addColorStop(i / (piece.gradient.length - 1), color);
            });
            
            ctx.fillStyle = gradient;
            ctx.fillRect(bx, by, size, size);
            
            // Inner border
            ctx.strokeStyle = piece.glow;
            ctx.lineWidth = 2;
            ctx.strokeRect(bx + 1, by + 1, size - 2, size - 2);
            
            // Corner highlights
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(bx + 2, by + 2, 8, 2);
            ctx.fillRect(bx + 2, by + 2, 2, 8);
            ctx.fillRect(bx + size - 10, by + 2, 8, 2);
            ctx.fillRect(bx + size - 4, by + 2, 2, 8);
            
            // Center gem
            const gemSize = 8;
            const gemX = bx + size/2 - gemSize/2;
            const gemY = by + size/2 - gemSize/2;
            
            const gemGradient = ctx.createRadialGradient(
                gemX + gemSize/2, gemY + gemSize/2, 0,
                gemX + gemSize/2, gemY + gemSize/2, gemSize
            );
            gemGradient.addColorStop(0, '#fff');
            gemGradient.addColorStop(0.5, piece.glow);
            gemGradient.addColorStop(1, piece.gradient[2]);
            
            ctx.fillStyle = gemGradient;
            ctx.fillRect(gemX, gemY, gemSize, gemSize);
            
            // Animated pulse
            if (isActive) {
                const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 0.8;
                ctx.strokeStyle = piece.glow + Math.floor(pulse * 255).toString(16);
                ctx.lineWidth = 3;
                ctx.strokeRect(bx - 2, by - 2, size + 4, size + 4);
            }
            
            ctx.restore();
        }
        
        // Draw next piece
        function drawNextPiece() {
            nextCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            if (nextPiece !== null) {
                const piece = PIECES[nextPiece];
                const blockSize = 22;
                const offsetX = (nextCanvas.width - piece.shape[0].length * blockSize) / 2;
                const offsetY = (nextCanvas.height - piece.shape.length * blockSize) / 2;
                
                // Draw grid background
                nextCtx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
                nextCtx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    nextCtx.beginPath();
                    nextCtx.moveTo(i * blockSize + offsetX - blockSize/2, 0);
                    nextCtx.lineTo(i * blockSize + offsetX - blockSize/2, nextCanvas.height);
                    nextCtx.stroke();
                    
                    nextCtx.beginPath();
                    nextCtx.moveTo(0, i * blockSize + offsetY - blockSize/2);
                    nextCtx.lineTo(nextCanvas.width, i * blockSize + offsetY - blockSize/2);
                    nextCtx.stroke();
                }
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const bx = offsetX + x * blockSize;
                            const by = offsetY + y * blockSize;
                            
                            // Mini version of Notamy block
                            const gradient = nextCtx.createLinearGradient(
                                bx, by, bx + blockSize, by + blockSize
                            );
                            piece.gradient.forEach((color, i) => {
                                gradient.addColorStop(i / (piece.gradient.length - 1), color);
                            });
                            
                            nextCtx.fillStyle = gradient;
                            nextCtx.fillRect(bx + 1, by + 1, blockSize - 2, blockSize - 2);
                            
                            nextCtx.strokeStyle = piece.glow;
                            nextCtx.lineWidth = 1;
                            nextCtx.strokeRect(bx + 1, by + 1, blockSize - 2, blockSize - 2);
                            
                            // Mini highlight
                            nextCtx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            nextCtx.fillRect(bx + 2, by + 2, 4, 1);
                            nextCtx.fillRect(bx + 2, by + 2, 1, 4);
                        }
                    }
                }
            }
        }
        
        // Update UI
        function updateUI() {
            const scoreEl = document.getElementById('scoreDisplay');
            const oldScore = parseInt(scoreEl.textContent);
            scoreEl.textContent = score.toLocaleString();
            
            if (score > oldScore) {
                scoreEl.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    scoreEl.style.transform = 'scale(1)';
                }, 200);
            }
            
            document.getElementById('linesDisplay').textContent = lines;
            document.getElementById('levelDisplay').textContent = level;
        }
        
        // Update timer
        function updateTimer() {
            const display = document.getElementById('timerDisplay');
            const bar = document.getElementById('timerBar');
            
            display.textContent = Math.ceil(timeLeft);
            
            const percentage = Math.max(0, timeLeft / INITIAL_TIME);
            bar.style.transform = `scaleY(${percentage})`;
            
            if (timeLeft < 10) {
                display.style.animation = 'timerPulse 0.5s ease-in-out infinite';
                bar.style.background = 'linear-gradient(90deg, #ff6b6b, #ff5252, #ff6b6b)';
            }
        }
        
        // Start game
        function startGame() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('gameOverOverlay').style.display = 'none';
            
            createBoard();
            score = 0;
            lines = 0;
            level = 1;
            timeLeft = INITIAL_TIME;
            currentDropSpeed = DROP_SPEED;
            dropTimer = 0;
            gameActive = true;
            
            currentPiece = createPiece(getRandomPiece());
            nextPiece = getRandomPiece();
            
            updateUI();
            
            lastTime = performance.now();
            requestAnimationFrame(update);
        }
        
        // Game over
        function gameOver() {
            gameActive = false;
            saveBestScore();
            
            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('finalLines').textContent = lines;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('bestScore').textContent = bestScore.toLocaleString();
            
            document.getElementById('gameOverOverlay').style.display = 'flex';
            
            // Epic explosion
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (board[y][x]) {
                        setTimeout(() => {
                            const rect = canvas.getBoundingClientRect();
                            const px = rect.left + x * BLOCK_SIZE + BLOCK_SIZE / 2;
                            const py = rect.top + y * BLOCK_SIZE + BLOCK_SIZE / 2;
                            const piece = PIECES[board[y][x] - 1];
                            
                            for (let i = 0; i < 8; i++) {
                                createParticle(px, py, {
                                    vx: (Math.random() - 0.5) * 500,
                                    vy: -Math.random() * 400 - 200,
                                    color: piece.glow,
                                    size: 12,
                                    type: 'explosion'
                                });
                            }
                        }, (BOARD_HEIGHT - y) * 30);
                    }
                }
            }
        }
        
        // Restart
        function restartGame() {
            startGame();
        }
        
        // Show welcome
        function showWelcome() {
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('welcomeScreen').style.display = 'flex';
        }
        
        // Initialize
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
